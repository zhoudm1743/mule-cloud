# Mule-Cloud 架构说明文档

## 📖 目录
- [架构概述](#架构概述)
- [三层架构详解](#三层架构详解)
- [是否每个接口都需要一个Endpoint？](#是否每个接口都需要一个endpoint)
- [快速开始：添加新接口](#快速开始添加新接口)
- [完整示例](#完整示例)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

---

## 架构概述

本项目采用 **Go-Kit 微服务框架** + **Gin HTTP框架** 的分层架构模式，遵循以下设计原则：

```
┌─────────────────────────────────────────┐
│         HTTP请求 (Gin Router)           │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│   Transport Layer (传输层)              │
│   - 参数绑定与验证                      │
│   - HTTP请求/响应处理                   │
│   - 调用Endpoint层                      │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│   Endpoint Layer (端点层)               │
│   - 请求/响应类型转换                   │
│   - 调用Service层                       │
│   - Go-Kit标准接口                      │
└──────────────┬──────────────────────────┘
               │
┌──────────────▼──────────────────────────┐
│   Service Layer (服务层)                │
│   - 业务逻辑实现                        │
│   - 数据处理                            │
│   - 返回结果                            │
└─────────────────────────────────────────┘
```

---

## 三层架构详解

### 1️⃣ Service Layer (服务层)
**位置**: `services/`

**职责**:
- 实现核心业务逻辑
- 不关心HTTP协议细节
- 可以被多种传输层复用 (HTTP, gRPC, etc.)

**示例**:
```go
// services/admin.go
package services

type IAdminService interface {
    Get(id string) (interface{}, error)
}

type AdminService struct{}

func (s *AdminService) Get(id string) (interface{}, error) {
    // 业务逻辑实现
    return id, nil
}

func NewAdminService() IAdminService {
    return &AdminService{}
}
```

### 2️⃣ Endpoint Layer (端点层)
**位置**: `endpoint/`

**职责**:
- 定义请求/响应结构体
- 将HTTP层的数据转换为Service层的参数
- 遵循Go-Kit的 `endpoint.Endpoint` 接口

**示例**:
```go
// endpoint/admin.go
package endpoint

import (
    "context"
    "github.com/go-kit/kit/endpoint"
)

// 请求结构
type AdminRequest struct {
    Id string `json:"id" form:"id" binding"required"`
}

// 响应结构
type AdminResponse struct {
    Result string `json:"result"`
}

// Endpoint函数
func GetAdminEndpoint(svc services.IAdminService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(AdminRequest)
        res, err := svc.Get(req.Id)
        if err != nil {
            return nil, err
        }
        return AdminResponse{Result: res.(string)}, nil
    }
}
```

### 3️⃣ Transport Layer (传输层)
**位置**: `transport/`

**职责**:
- 处理HTTP请求绑定
- 参数验证
- 调用Endpoint
- 统一响应格式

**示例**:
```go
// transport/admin.go
package transport

func AdminGetHandler(svc services.IAdminService) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 参数绑定
        var req endpoint.AdminRequest
        if err := c.ShouldBindQuery(&req); err != nil {
            response.Error(c, "参数错误: "+err.Error())
            return
        }

        // 2. 参数校验
        if req.Id == "" {
            response.Error(c, "id不能为空")
            return
        }

        // 3. 调用endpoint
        ep := endpoint.GetAdminEndpoint(svc)
        resp, err := ep(c.Request.Context(), req)
        if err != nil {
            response.Error(c, err.Error())
            return
        }

        // 4. 返回响应
        response.Success(c, resp)
    }
}
```

---

## 是否每个接口都需要一个Endpoint？

### ✅ 标准答案：是的

**在标准的Go-Kit架构中，每个接口（API）都应该有一个对应的Endpoint函数。**

### 🤔 为什么这样设计？

1. **清晰的职责分离**: 每个Endpoint专注于一个具体的业务操作
2. **类型安全**: 每个操作有明确的请求/响应类型
3. **可测试性**: 每个Endpoint可以独立测试
4. **可维护性**: 代码结构清晰，易于维护
5. **可扩展性**: 方便后续添加中间件（日志、监控、鉴权等）

### 💡 但是可以优化！

虽然每个接口需要一个Endpoint，但**同一个服务的多个接口可以放在同一个文件中**：

```go
// endpoint/admin.go
package endpoint

// Admin服务的所有Endpoint都在这个文件

// GET /admin
func GetAdminEndpoint(svc services.IAdminService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        // ...
    }
}

// POST /admin
func CreateAdminEndpoint(svc services.IAdminService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        // ...
    }
}

// PUT /admin/:id
func UpdateAdminEndpoint(svc services.IAdminService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        // ...
    }
}

// DELETE /admin/:id
func DeleteAdminEndpoint(svc services.IAdminService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        // ...
    }
}
```

---

## 快速开始：添加新接口

### 场景：添加一个用户管理模块的 `GET /user/:id` 接口

#### 步骤 1: 创建 Service 层

```bash
创建文件: services/user.go
```

```go
package services

type IUserService interface {
    GetById(id string) (*User, error)
}

type UserService struct {
    // 可以注入数据库连接等依赖
}

type User struct {
    Id   string `json:"id"`
    Name string `json:"name"`
    Age  int    `json:"age"`
}

func (s *UserService) GetById(id string) (*User, error) {
    // 实际业务逻辑：从数据库查询用户
    return &User{
        Id:   id,
        Name: "张三",
        Age:  25,
    }, nil
}

func NewUserService() IUserService {
    return &UserService{}
}
```

#### 步骤 2: 创建 Endpoint 层

```bash
创建文件: endpoint/user.go
```

```go
package endpoint

import (
    "context"
    "mule-cloud/test/services"
    "github.com/go-kit/kit/endpoint"
)

// 请求结构
type GetUserRequest struct {
    Id string `json:"id" uri:"id" binding"required"`
}

// 响应结构
type GetUserResponse struct {
    User *services.User `json:"user"`
}

// Endpoint函数
func GetUserEndpoint(svc services.IUserService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(GetUserRequest)
        user, err := svc.GetById(req.Id)
        if err != nil {
            return nil, err
        }
        return GetUserResponse{User: user}, nil
    }
}
```

#### 步骤 3: 创建 Transport 层

```bash
创建文件: transport/user.go
```

```go
package transport

import (
    "mule-cloud/core/response"
    "mule-cloud/test/endpoint"
    "mule-cloud/test/services"
    "github.com/gin-gonic/gin"
)

func UserGetByIdHandler(svc services.IUserService) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 1. 参数绑定
        var req endpoint.GetUserRequest
        if err := c.ShouldBindUri(&req); err != nil {
            response.Error(c, "参数错误: "+err.Error())
            return
        }

        // 2. 调用endpoint
        ep := endpoint.GetUserEndpoint(svc)
        resp, err := ep(c.Request.Context(), req)
        if err != nil {
            response.Error(c, err.Error())
            return
        }

        // 3. 返回响应
        response.Success(c, resp)
    }
}
```

#### 步骤 4: 注册路由

```bash
修改文件: cmd/main.go
```

```go
package main

import (
    "mule-cloud/test/services"
    "mule-cloud/test/transport"
    "github.com/gin-gonic/gin"
)

func main() {
    // 初始化服务
    adminSvc := services.NewAdminService()
    userSvc := services.NewUserService()  // 新增

    // 初始化路由
    r := gin.Default()

    // Admin路由组
    admin := r.Group("/admin")
    {
        admin.GET("/", transport.AdminGetHandler(adminSvc))
    }

    // User路由组 (新增)
    user := r.Group("/user")
    {
        user.GET("/:id", transport.UserGetByIdHandler(userSvc))
    }

    // 启动服务
    r.Run(":8080")
}
```

#### ✅ 完成！测试接口

```bash
curl http://localhost:8080/user/123
```

---

## 完整示例

### 示例：实现完整的 CRUD 操作

#### 1. Service 层 (services/product.go)

```go
package services

type IProductService interface {
    List() ([]*Product, error)
    GetById(id string) (*Product, error)
    Create(name string, price float64) (*Product, error)
    Update(id, name string, price float64) error
    Delete(id string) error
}

type Product struct {
    Id    string  `json:"id"`
    Name  string  `json:"name"`
    Price float64 `json:"price"`
}

type ProductService struct {
    // 内存存储（实际应使用数据库）
    products map[string]*Product
}

func NewProductService() IProductService {
    return &ProductService{
        products: make(map[string]*Product),
    }
}

func (s *ProductService) List() ([]*Product, error) {
    list := make([]*Product, 0, len(s.products))
    for _, p := range s.products {
        list = append(list, p)
    }
    return list, nil
}

func (s *ProductService) GetById(id string) (*Product, error) {
    if p, ok := s.products[id]; ok {
        return p, nil
    }
    return nil, fmt.Errorf("产品不存在")
}

func (s *ProductService) Create(name string, price float64) (*Product, error) {
    id := fmt.Sprintf("P%d", time.Now().Unix())
    p := &Product{Id: id, Name: name, Price: price}
    s.products[id] = p
    return p, nil
}

func (s *ProductService) Update(id, name string, price float64) error {
    if p, ok := s.products[id]; ok {
        p.Name = name
        p.Price = price
        return nil
    }
    return fmt.Errorf("产品不存在")
}

func (s *ProductService) Delete(id string) error {
    if _, ok := s.products[id]; ok {
        delete(s.products, id)
        return nil
    }
    return fmt.Errorf("产品不存在")
}
```

#### 2. Endpoint 层 (endpoint/product.go)

```go
package endpoint

import (
    "context"
    "mule-cloud/test/services"
    "github.com/go-kit/kit/endpoint"
)

// ===== List =====
type ListProductRequest struct{}

type ListProductResponse struct {
    Products []*services.Product `json:"products"`
}

func ListProductEndpoint(svc services.IProductService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        products, err := svc.List()
        if err != nil {
            return nil, err
        }
        return ListProductResponse{Products: products}, nil
    }
}

// ===== Get =====
type GetProductRequest struct {
    Id string `uri:"id" binding"required"`
}

type GetProductResponse struct {
    Product *services.Product `json:"product"`
}

func GetProductEndpoint(svc services.IProductService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(GetProductRequest)
        product, err := svc.GetById(req.Id)
        if err != nil {
            return nil, err
        }
        return GetProductResponse{Product: product}, nil
    }
}

// ===== Create =====
type CreateProductRequest struct {
    Name  string  `json:"name" binding"required"`
    Price float64 `json:"price" binding"required"`
}

type CreateProductResponse struct {
    Product *services.Product `json:"product"`
}

func CreateProductEndpoint(svc services.IProductService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(CreateProductRequest)
        product, err := svc.Create(req.Name, req.Price)
        if err != nil {
            return nil, err
        }
        return CreateProductResponse{Product: product}, nil
    }
}

// ===== Update =====
type UpdateProductRequest struct {
    Id    string  `uri:"id" binding"required"`
    Name  string  `json:"name" binding"required"`
    Price float64 `json:"price" binding"required"`
}

type UpdateProductResponse struct {
    Message string `json:"message"`
}

func UpdateProductEndpoint(svc services.IProductService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(UpdateProductRequest)
        err := svc.Update(req.Id, req.Name, req.Price)
        if err != nil {
            return nil, err
        }
        return UpdateProductResponse{Message: "更新成功"}, nil
    }
}

// ===== Delete =====
type DeleteProductRequest struct {
    Id string `uri:"id" binding"required"`
}

type DeleteProductResponse struct {
    Message string `json:"message"`
}

func DeleteProductEndpoint(svc services.IProductService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(DeleteProductRequest)
        err := svc.Delete(req.Id)
        if err != nil {
            return nil, err
        }
        return DeleteProductResponse{Message: "删除成功"}, nil
    }
}
```

#### 3. Transport 层 (transport/product.go)

```go
package transport

import (
    "mule-cloud/core/response"
    "mule-cloud/test/endpoint"
    "mule-cloud/test/services"
    "github.com/gin-gonic/gin"
)

// GET /product
func ProductListHandler(svc services.IProductService) gin.HandlerFunc {
    return func(c *gin.Context) {
        ep := endpoint.ListProductEndpoint(svc)
        resp, err := ep(c.Request.Context(), endpoint.ListProductRequest{})
        if err != nil {
            response.Error(c, err.Error())
            return
        }
        response.Success(c, resp)
    }
}

// GET /product/:id
func ProductGetHandler(svc services.IProductService) gin.HandlerFunc {
    return func(c *gin.Context) {
        var req endpoint.GetProductRequest
        if err := c.ShouldBindUri(&req); err != nil {
            response.Error(c, "参数错误: "+err.Error())
            return
        }

        ep := endpoint.GetProductEndpoint(svc)
        resp, err := ep(c.Request.Context(), req)
        if err != nil {
            response.Error(c, err.Error())
            return
        }
        response.Success(c, resp)
    }
}

// POST /product
func ProductCreateHandler(svc services.IProductService) gin.HandlerFunc {
    return func(c *gin.Context) {
        var req endpoint.CreateProductRequest
        if err := c.ShouldBindJSON(&req); err != nil {
            response.Error(c, "参数错误: "+err.Error())
            return
        }

        ep := endpoint.CreateProductEndpoint(svc)
        resp, err := ep(c.Request.Context(), req)
        if err != nil {
            response.Error(c, err.Error())
            return
        }
        response.Success(c, resp)
    }
}

// PUT /product/:id
func ProductUpdateHandler(svc services.IProductService) gin.HandlerFunc {
    return func(c *gin.Context) {
        var req endpoint.UpdateProductRequest
        if err := c.ShouldBindUri(&req); err != nil {
            response.Error(c, "参数错误: "+err.Error())
            return
        }
        if err := c.ShouldBindJSON(&req); err != nil {
            response.Error(c, "参数错误: "+err.Error())
            return
        }

        ep := endpoint.UpdateProductEndpoint(svc)
        resp, err := ep(c.Request.Context(), req)
        if err != nil {
            response.Error(c, err.Error())
            return
        }
        response.Success(c, resp)
    }
}

// DELETE /product/:id
func ProductDeleteHandler(svc services.IProductService) gin.HandlerFunc {
    return func(c *gin.Context) {
        var req endpoint.DeleteProductRequest
        if err := c.ShouldBindUri(&req); err != nil {
            response.Error(c, "参数错误: "+err.Error())
            return
        }

        ep := endpoint.DeleteProductEndpoint(svc)
        resp, err := ep(c.Request.Context(), req)
        if err != nil {
            response.Error(c, err.Error())
            return
        }
        response.Success(c, resp)
    }
}
```

#### 4. 注册路由

```go
package main

func main() {
    productSvc := services.NewProductService()
    
    r := gin.Default()
    
    product := r.Group("/product")
    {
        product.GET("", transport.ProductListHandler(productSvc))
        product.GET("/:id", transport.ProductGetHandler(productSvc))
        product.POST("", transport.ProductCreateHandler(productSvc))
        product.PUT("/:id", transport.ProductUpdateHandler(productSvc))
        product.DELETE("/:id", transport.ProductDeleteHandler(productSvc))
    }
    
    r.Run(":8080")
}
```

---

## 最佳实践

### 1. 文件组织建议

```
project/
├── cmd/
│   └── main.go              # 程序入口
├── services/
│   ├── admin.go             # Admin服务
│   ├── user.go              # User服务
│   └── product.go           # Product服务
├── endpoint/
│   ├── admin.go             # Admin所有endpoint
│   ├── user.go              # User所有endpoint
│   └── product.go           # Product所有endpoint
├── transport/
│   ├── admin.go             # Admin所有handler
│   ├── user.go              # User所有handler
│   └── product.go           # Product所有handler
└── core/
    └── response/
        └── response.go      # 统一响应
```

### 2. 命名规范

- **Service接口**: `I{模块}Service`，如 `IUserService`
- **Service实现**: `{模块}Service`，如 `UserService`
- **Endpoint函数**: `{操作}{模块}Endpoint`，如 `GetUserEndpoint`
- **Transport函数**: `{模块}{操作}Handler`，如 `UserGetHandler`
- **Request结构**: `{操作}{模块}Request`，如 `GetUserRequest`
- **Response结构**: `{操作}{模块}Response`，如 `GetUserResponse`

### 3. 参数绑定方式

| 绑定方式 | 使用场景 | Tag | Gin方法 |
|---------|---------|-----|---------|
| Query参数 | `?id=123` | `form:"id"` | `ShouldBindQuery` |
| URI参数 | `/:id` | `uri:"id"` | `ShouldBindUri` |
| JSON Body | POST/PUT请求体 | `json:"name"` | `ShouldBindJSON` |
| Form表单 | 表单提交 | `form:"name"` | `ShouldBind` |

### 4. 错误处理

建议在 `core/response` 中扩展错误处理：

```go
// response/response.go
package response

import (
    "net/http"
    "github.com/gin-gonic/gin"
)

// 错误码定义
const (
    CodeSuccess      = 0
    CodeParamError   = 1001
    CodeNotFound     = 1002
    CodeServerError  = 1003
    CodeUnauthorized = 1004
)

type Response struct {
    Code int         `json:"code"`
    Msg  string      `json:"msg"`
    Data interface{} `json:"data,omitempty"`
}

func Success(c *gin.Context, data interface{}) {
    c.JSON(http.StatusOK, Response{
        Code: CodeSuccess,
        Msg:  "success",
        Data: data,
    })
}

func Error(c *gin.Context, msg string) {
    c.JSON(http.StatusOK, Response{
        Code: CodeServerError,
        Msg:  msg,
    })
}

func ErrorWithCode(c *gin.Context, code int, msg string) {
    c.JSON(http.StatusOK, Response{
        Code: code,
        Msg:  msg,
    })
}

func ParamError(c *gin.Context, msg string) {
    c.JSON(http.StatusOK, Response{
        Code: CodeParamError,
        Msg:  msg,
    })
}

func NotFound(c *gin.Context, msg string) {
    c.JSON(http.StatusOK, Response{
        Code: CodeNotFound,
        Msg:  msg,
    })
}
```

### 5. 添加中间件支持

Endpoint层可以很方便地添加中间件（日志、监控、鉴权等）：

```go
// endpoint/middleware.go
package endpoint

import (
    "context"
    "log"
    "time"
    "github.com/go-kit/kit/endpoint"
)

// 日志中间件
func LoggingMiddleware(logger *log.Logger) endpoint.Middleware {
    return func(next endpoint.Endpoint) endpoint.Endpoint {
        return func(ctx context.Context, request interface{}) (interface{}, error) {
            start := time.Now()
            logger.Printf("开始处理请求: %+v", request)
            
            response, err := next(ctx, request)
            
            logger.Printf("请求处理完成，耗时: %v, 错误: %v", time.Since(start), err)
            return response, err
        }
    }
}

// 鉴权中间件
func AuthMiddleware(requiredRole string) endpoint.Middleware {
    return func(next endpoint.Endpoint) endpoint.Endpoint {
        return func(ctx context.Context, request interface{}) (interface{}, error) {
            // 从context中获取用户信息
            userRole := ctx.Value("user_role").(string)
            if userRole != requiredRole {
                return nil, fmt.Errorf("权限不足")
            }
            return next(ctx, request)
        }
    }
}

// 使用中间件
func GetAdminEndpoint(svc services.IAdminService) endpoint.Endpoint {
    ep := makeGetAdminEndpoint(svc)
    ep = LoggingMiddleware(logger)(ep)
    ep = AuthMiddleware("admin")(ep)
    return ep
}
```

---

## 常见问题

### Q1: 为什么要用三层架构？直接在Handler里写业务逻辑不行吗？

**A**: 可以，但不推荐。三层架构的优势：
- **可测试性**: Service层可以单独测试，不需要启动HTTP服务
- **可复用性**: 同一个Service可以被HTTP、gRPC、消息队列等多种传输层使用
- **可维护性**: 职责清晰，修改更安全
- **可扩展性**: 方便添加中间件、监控等

### Q2: 简单的CRUD操作也需要这么复杂吗？

**A**: 根据项目规模选择：
- **小型项目/原型**: 可以简化，Transport直接调用Service
- **中大型项目**: 建议完整使用，便于后期维护和扩展

### Q3: 如何减少重复代码？

**A**: 可以使用代码生成工具，或者封装通用的Handler：

```go
// transport/common.go
func MakeHandler(ep endpoint.Endpoint, bindFunc func(*gin.Context) (interface{}, error)) gin.HandlerFunc {
    return func(c *gin.Context) {
        req, err := bindFunc(c)
        if err != nil {
            response.ParamError(c, err.Error())
            return
        }
        
        resp, err := ep(c.Request.Context(), req)
        if err != nil {
            response.Error(c, err.Error())
            return
        }
        
        response.Success(c, resp)
    }
}

// 使用
func UserGetHandler(svc services.IUserService) gin.HandlerFunc {
    return MakeHandler(
        endpoint.GetUserEndpoint(svc),
        func(c *gin.Context) (interface{}, error) {
            var req endpoint.GetUserRequest
            err := c.ShouldBindUri(&req)
            return req, err
        },
    )
}
```

### Q4: Service层应该返回 `interface{}` 还是具体类型？

**A**: 建议返回具体类型，更安全：

```go
// 推荐
func (s *UserService) GetById(id string) (*User, error) {
    return &User{}, nil
}

// 不推荐
func (s *UserService) GetById(id string) (interface{}, error) {
    return &User{}, nil
}
```

### Q5: 如何处理数据库连接？

**A**: 在Service初始化时注入：

```go
type UserService struct {
    db *gorm.DB
}

func NewUserService(db *gorm.DB) IUserService {
    return &UserService{db: db}
}

// main.go
db := initDatabase()
userSvc := services.NewUserService(db)
```

---

## 总结

| 层级 | 职责 | 是否必须每个接口一个 |
|------|------|---------------------|
| Service | 业务逻辑 | ✅ 每个业务方法一个 |
| Endpoint | 类型转换 | ✅ 每个接口一个Endpoint函数 |
| Transport | HTTP处理 | ✅ 每个接口一个Handler |

**关键点**:
- ✅ 每个API接口需要一个Endpoint函数
- ✅ 但同一个模块的所有Endpoint可以放在一个文件中
- ✅ 这种设计利大于弊，特别是在中大型项目中

---

## 📚 参考资料

- [Go-Kit 官方文档](https://gokit.io/)
- [Gin 框架文档](https://gin-gonic.com/)
- [Go 微服务最佳实践](https://github.com/golang-standards/project-layout)

---

**文档版本**: v1.0  
**最后更新**: 2025-09-30  
**维护者**: Mule-Cloud Team
