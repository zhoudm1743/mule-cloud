# 订单追加数量解决方案

## 📋 业务场景

订单已进入生产（已创建裁剪任务或已开始裁剪），客户要求追加数量。

### 现实案例
```
原订单：合同号202510067553，1000件
已裁剪：500件（5个批次，每批次100件）
客户追加：+200件
期望结果：订单变成1200件，新增2个裁剪批次
```

---

## 🎯 推荐方案对比

### 方案1：订单追加功能（推荐用于后期开发）⭐⭐⭐⭐⭐

#### 功能设计

**1. 订单模型扩展**
```go
type Order struct {
    // 原有字段...
    Quantity          int     `json:"quantity"`           // 当前总数量
    OriginalQuantity  int     `json:"original_quantity"`  // 原始下单数量
    AddedQuantity     int     `json:"added_quantity"`     // 累计追加数量
    AddHistory        []AddRecord `json:"add_history"`    // 追加历史
}

type AddRecord struct {
    Quantity   int    `json:"quantity"`    // 本次追加数量
    Reason     string `json:"reason"`      // 追加原因
    AddedBy    string `json:"added_by"`    // 追加人
    AddedAt    int64  `json:"added_at"`    // 追加时间
}
```

**2. 前端界面**

订单列表增加"追加"按钮：
```
操作栏：
[详情] [编辑] [裁剪] [复制] [追加] [删除]
                              ↑ 新增
```

追加弹窗：
```
┌────────────────────────────┐
│   订单追加                  │
├────────────────────────────┤
│ 原始数量：1000件            │
│ 已追加：  0件               │
│ 当前总量：1000件            │
│                            │
│ 本次追加数量：[___] 件      │
│ 追加原因：                  │
│ [_____________________]    │
│                            │
│     [取消]    [确认追加]    │
└────────────────────────────┘
```

**3. 后端API**

```go
// POST /order/orders/:id/add-quantity
type OrderAddQuantityRequest struct {
    ID          string `uri:"id" binding"required"`
    AddQuantity int    `json:"add_quantity" binding"required,gt=0"`
    Reason      string `json:"reason"`
    AddedBy     string `json:"added_by"`
}

func (s *OrderService) AddQuantity(ctx context.Context, req *dto.OrderAddQuantityRequest) error {
    // 1. 获取订单
    order, err := s.repo.Get(ctx, req.ID)
    if err != nil {
        return err
    }
    
    // 2. 检查订单状态（草稿状态不允许追加，应该直接修改）
    if order.Status == 0 {
        return fmt.Errorf("草稿状态订单请直接修改数量")
    }
    
    // 3. 更新订单数量
    if order.OriginalQuantity == 0 {
        order.OriginalQuantity = order.Quantity  // 第一次追加时记录原始数量
    }
    order.AddedQuantity += req.AddQuantity
    order.Quantity += req.AddQuantity
    order.TotalAmount = float64(order.Quantity) * order.UnitPrice
    
    // 4. 记录追加历史
    addRecord := models.AddRecord{
        Quantity: req.AddQuantity,
        Reason:   req.Reason,
        AddedBy:  req.AddedBy,
        AddedAt:  time.Now().Unix(),
    }
    order.AddHistory = append(order.AddHistory, addRecord)
    
    // 5. 更新订单
    err = s.repo.Update(ctx, req.ID, bson.M{
        "quantity":          order.Quantity,
        "original_quantity": order.OriginalQuantity,
        "added_quantity":    order.AddedQuantity,
        "total_amount":      order.TotalAmount,
        "add_history":       order.AddHistory,
        "updated_at":        time.Now().Unix(),
    })
    if err != nil {
        return err
    }
    
    // 6. 更新裁剪任务总件数
    task, err := s.cuttingTaskRepo.GetByOrderID(ctx, req.ID)
    if err == nil && task != nil {
        task.TotalPieces += req.AddQuantity
        _ = s.cuttingTaskRepo.Update(ctx, task.ID, task)
    }
    
    return nil
}
```

**4. 追加后的裁剪流程**

用户追加数量后：
1. 订单总数量自动更新：1000 → 1200
2. 裁剪任务总件数更新：1000 → 1200
3. 用户继续创建裁剪批次（制菲）补足追加的数量
4. 进度计算基于新的总数量

#### 优点
- ✅ 保留完整的追加历史
- ✅ 数据结构清晰
- ✅ 便于统计和审计
- ✅ 支持多次追加

#### 缺点
- ❌ 需要开发新功能（约1-2天）

---

### 方案2：使用"复制订单"功能（立即可用）⭐⭐⭐⭐

#### 操作流程

**步骤1：复制原订单**
```
订单列表中找到原订单 → 点击"复制"按钮
```

**步骤2：修改复制后的订单**
```
合同号：202510067553-追加  （添加-追加后缀）
数量：200件                （只填追加的数量）
备注：原订单202510067553追加200件
```

**步骤3：创建裁剪任务**
```
正常流程：点击"裁剪" → 创建裁剪批次
```

**步骤4：统计时合并**
```
在统计报表中，通过合同号前缀匹配合并数据
SELECT * FROM orders WHERE contract_no LIKE '202510067553%'
```

#### 实际使用示例

**原订单**
- 合同号：202510067553
- 数量：1000件
- 状态：生产中
- 已裁剪：500件

**追加订单（复制而来）**
- 合同号：202510067553-追加1
- 数量：200件
- 状态：已下单
- 备注：原订单202510067553追加200件

#### 优点
- ✅ **立即可用**，无需开发
- ✅ 操作简单，不易出错
- ✅ 数据分离清晰
- ✅ 原订单不受影响

#### 缺点
- ❌ 两个订单独立，查询时需要关联
- ❌ 需要手动在备注中说明关联关系
- ❌ 统计时需要合并计算

#### 改进建议

可以在合同号命名上做约定：
```
原订单：202510067553
追加1：  202510067553-A1
追加2：  202510067553-A2
```

---

### 方案3：直接修改+限制（需要代码改造）⭐⭐⭐

#### 功能设计

**1. 修改订单编辑逻辑**

```go
func (s *OrderService) Update(ctx context.Context, req dto.OrderUpdateRequest) (*models.Order, error) {
    // 获取原订单
    oldOrder, err := s.repo.Get(ctx, req.ID)
    if err != nil {
        return nil, err
    }
    
    // 如果订单已进入生产，数量只能增加不能减少
    if oldOrder.Status >= 1 { // 已下单、生产中、已完成
        if req.Quantity < oldOrder.Quantity {
            return nil, fmt.Errorf("生产中的订单数量不能减少，当前数量：%d", oldOrder.Quantity)
        }
        
        // 如果增加数量，更新裁剪任务
        if req.Quantity > oldOrder.Quantity {
            addedQty := req.Quantity - oldOrder.Quantity
            
            // 更新裁剪任务总件数
            task, _ := s.cuttingTaskRepo.GetByOrderID(ctx, req.ID)
            if task != nil {
                task.TotalPieces += addedQty
                _ = s.cuttingTaskRepo.Update(ctx, task.ID, task)
            }
        }
    }
    
    // 正常的更新流程...
}
```

**2. 前端提示**

修改订单数量时：
```javascript
if (modalType.value === 'edit' && order.status >= 1) {
  // 显示提示
  window.$message.info('订单已进入生产，数量只能增加不能减少');
  
  // 设置最小值
  quantityMin.value = order.quantity;
}
```

#### 使用流程

1. 点击订单"编辑"
2. 修改数量：1000 → 1200
3. 系统自动：
   - 更新订单总数量
   - 更新裁剪任务总件数
   - 更新总金额
4. 用户继续创建裁剪批次补足200件

#### 优点
- ✅ 操作直观简单
- ✅ 数据统一，无需合并

#### 缺点
- ❌ 没有追加历史记录
- ❌ 不知道哪些是原始订单，哪些是追加的
- ❌ 如果有颜色尺码明细，修改会很复杂

---

## 🎨 颜色尺码组合的特殊处理

### 问题
如果订单有颜色尺码明细：
```
蓝色-L：100件
蓝色-XL：150件
红色-L：120件
...
总计：1000件
```

追加200件应该怎么分配到各个组合？

### 解决方案

#### 选项A：按比例分配（自动）
```javascript
// 计算每个组合的比例
const total = order.items.reduce((sum, item) => sum + item.quantity, 0);
const addQuantity = 200;

order.items.forEach(item => {
  const ratio = item.quantity / total;
  const addQty = Math.round(addQuantity * ratio);
  item.quantity += addQty;
});
```

#### 选项B：手动指定（灵活）
```
追加弹窗中显示颜色尺码表格，让用户填写每个组合追加多少件：

颜色  尺码  原数量  追加数量
蓝色  L    100     [20]
蓝色  XL   150     [30]
红色  L    120     [25]
...

总计追加：200件
```

---

## 📊 推荐选择

### 当前阶段（立即可用）→ 方案2
**使用"复制订单"功能**
- 优点：无需开发，立即可用
- 适用：临时方案，追加频率不高
- 操作：复制 → 修改数量 → 创建裁剪任务

### 后期优化（小程序上线后）→ 方案1
**开发"订单追加"功能**
- 优点：功能完整，体验好
- 时机：与小程序一起开发
- 内容：追加按钮 + 追加历史 + 自动同步

---

## 🔧 方案2的具体操作指南

### 操作步骤

**1. 找到原订单**
```
订单管理 → 搜索合同号：202510067553
```

**2. 点击"复制"**
```
操作栏：[详情] [编辑] [裁剪] [复制] ← 点这里
```

**3. 修改复制的订单**
```
合同号：202510067553-A1      （添加后缀区分）
客户：  XX服装厂            （保持不变）
数量：  200件               （只填追加数量）
单价：  2.00               （保持不变）
备注：  原单202510067553追加200件，2024-10-07
```

**4. 保存并创建裁剪任务**
```
保存订单 → 点击"裁剪" → 创建裁剪批次
```

**5. 统计时合并**
```
订单列表搜索：202510067553
会同时显示：
- 202510067553 (1000件)
- 202510067553-A1 (200件)

手动合并统计即可
```

### 命名规范建议

```
原订单：{合同号}
追加1： {合同号}-A1
追加2： {合同号}-A2
追加3： {合同号}-A3
```

例如：
- 202510067553
- 202510067553-A1
- 202510067553-A2

---

## 💻 方案1的实现代码（供后期参考）

### 1. 数据模型扩展

```go
// internal/models/order.go
type Order struct {
    // ...现有字段
    OriginalQuantity int         `json:"original_quantity" bson:"original_quantity"` // 原始数量
    AddedQuantity    int         `json:"added_quantity" bson:"added_quantity"`       // 追加数量
    AddHistory       []AddRecord `json:"add_history" bson:"add_history"`             // 追加历史
}

type AddRecord struct {
    Quantity int    `json:"quantity" bson:"quantity"`       // 追加数量
    Reason   string `json:"reason" bson:"reason"`           // 追加原因
    AddedBy  string `json:"added_by" bson:"added_by"`       // 追加人
    AddedAt  int64  `json:"added_at" bson:"added_at"`       // 追加时间
}
```

### 2. DTO定义

```go
// app/order/dto/order.go
type OrderAddQuantityRequest struct {
    ID          string `uri:"id" binding"required"`
    AddQuantity int    `json:"add_quantity" binding"required,gt=0"`
    Reason      string `json:"reason"`
    AddedBy     string `json:"added_by"`
}

type OrderAddQuantityResponse struct {
    Order *models.Order `json:"order"`
}
```

### 3. Service层

```go
// app/order/services/order.go
func (s *OrderService) AddQuantity(ctx context.Context, req dto.OrderAddQuantityRequest) (*models.Order, error) {
    // 获取订单
    order, err := s.repo.Get(ctx, req.ID)
    if err != nil {
        return nil, err
    }
    
    // 草稿状态不允许追加
    if order.Status == 0 {
        return nil, fmt.Errorf("草稿状态订单请直接修改数量")
    }
    
    // 第一次追加时记录原始数量
    if order.OriginalQuantity == 0 {
        order.OriginalQuantity = order.Quantity
    }
    
    // 更新数量
    order.AddedQuantity += req.AddQuantity
    order.Quantity += req.AddQuantity
    order.TotalAmount = float64(order.Quantity) * order.UnitPrice
    
    // 记录追加历史
    addRecord := models.AddRecord{
        Quantity: req.AddQuantity,
        Reason:   req.Reason,
        AddedBy:  req.AddedBy,
        AddedAt:  time.Now().Unix(),
    }
    order.AddHistory = append(order.AddHistory, addRecord)
    
    // 更新数据库
    update := bson.M{
        "quantity":          order.Quantity,
        "original_quantity": order.OriginalQuantity,
        "added_quantity":    order.AddedQuantity,
        "total_amount":      order.TotalAmount,
        "add_history":       order.AddHistory,
        "updated_at":        time.Now().Unix(),
    }
    
    err = s.repo.Update(ctx, req.ID, update)
    if err != nil {
        return nil, err
    }
    
    // 更新裁剪任务
    task, _ := s.cuttingTaskRepo.GetByOrderID(ctx, req.ID)
    if task != nil {
        task.TotalPieces += req.AddQuantity
        _ = s.cuttingTaskRepo.Update(ctx, task.ID, task)
    }
    
    return s.repo.Get(ctx, req.ID)
}
```

### 4. 前端实现

```vue
<!-- 订单列表 -->
<template>
  <NButton 
    size="small" 
    type="warning"
    @click="handleAddQuantity(row)"
  >
    追加
  </NButton>
</template>

<script setup>
// 追加数量弹窗
const addQuantityModal = ref(false);
const addQuantityForm = ref({
  add_quantity: 0,
  reason: ''
});

async function handleAddQuantity(order) {
  currentOrder.value = order;
  addQuantityForm.value = {
    add_quantity: 0,
    reason: ''
  };
  addQuantityModal.value = true;
}

async function confirmAddQuantity() {
  try {
    await addOrderQuantity(currentOrder.value.id, addQuantityForm.value);
    window.$message.success('追加成功');
    addQuantityModal.value = false;
    fetchData();
  } catch (error) {
    window.$message.error(error.message || '追加失败');
  }
}
</script>
```

---

## 📌 总结

### 立即使用（推荐）
👉 **方案2：复制订单**
- 无需开发
- 操作简单
- 合同号加后缀区分

### 后期开发（理想）
👉 **方案1：订单追加功能**
- 保留历史
- 数据完整
- 体验更好

根据您当前的情况，建议先用方案2（复制订单）解决燃眉之急，等小程序开发时再实现方案1的完整功能。
