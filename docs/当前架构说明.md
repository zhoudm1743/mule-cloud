# 当前租户隔离架构说明

## 架构概述

采用**数据库级别物理隔离**模式：
- **系统库（tenant_system）**：存储租户元数据（tenant表）和菜单配置（menu表）
- **租户库（mule_xxx）**：每个租户拥有独立数据库，存储该租户的所有业务数据

## 数据分布

### 系统库（tenant_system）
```
- tenant     // 租户元数据（无 tenant_id）
- menu       // 菜单配置（无 tenant_id，全局共享）
```

### 租户库（mule_{tenantID}）
```
- admin      // 管理员（无 tenant_id）
- role       // 角色（无 tenant_id）
- color      // 颜色
- customer   // 客户
- order_type // 订单类型
- procedure  // 工序
- salesman   // 业务员
- size       // 尺寸
... 其他业务数据
```

## 核心机制

### 1. Context 传递租户信息
```go
// 在 Gateway 中间件提取 JWT 中的 tenant_id
tenantID := claims.TenantID
ctx = tenantCtx.WithTenantID(ctx, tenantID)
```

### 2. DatabaseManager 自动切换数据库
```go
// Repository 的 getCollection 自动切换数据库
func (r *adminRepository) getCollection(ctx context.Context) *mongo.Collection {
    tenantID := tenantCtx.GetTenantID(ctx)
    db := r.dbManager.GetDatabase(tenantID) // 自动切换到 mule_{tenantID}
    return db.Collection("admin")
}
```

### 3. 特殊处理
- **Menu 和 Tenant**：始终使用系统库
- **其他所有表**：根据 context 中的 tenant_id 自动切换到对应租户库

## 关键优化

### 1. Auth 服务直接查询 Role（已修复）
```go
// 修改前：通过 HTTP 调用 system 服务（会丢失租户上下文）
err := s.httpClient.CallService(ctx, "GET", "systemservice", path, nil, &roleResult, nil)

// 修改后：直接使用 RoleRepository（自动携带租户上下文）
role, err := s.roleRepo.Get(ctx, roleID)
```

### 2. Menu Repository 始终使用系统库
```go
func (r *MenuRepository) getCollection(ctx context.Context) *mongo.Collection {
    db := r.dbManager.GetDatabase("") // 空字符串 = 系统库
    return db.Collection("menu")
}
```

### 3. 支持混合 _id 类型（兼容 Python 脚本）
```go
// 先尝试字符串 _id 查询
filter := bson.M{"_id": id, "is_deleted": 0}
err := collection.FindOne(ctx, filter).Decode(&menu)

// 失败后尝试 ObjectID 查询
if err == mongo.ErrNoDocuments {
    objectID, _ := bson.ObjectIDFromHex(id)
    filter = bson.M{"_id": objectID, "is_deleted": 0}
    err = collection.FindOne(ctx, filter).Decode(&menu)
}
```

## 租户创建流程

1. 在系统库创建租户记录（tenant_system.tenant）
2. 创建租户专属数据库（mule_{tenantID}）
3. 在租户库创建默认角色（mule_{tenantID}.role）
4. 在租户库创建租户管理员（mule_{tenantID}.admin）

## 登录流程

### 系统管理员登录
```
POST /admin/auth/login
{
    "phone": "17858361617",
    "password": "123456"
    // 无 tenant_code
}
→ 查询系统库（tenant_system.admin）
→ 返回 JWT（tenant_id = ""）
```

### 租户用户登录
```
POST /admin/auth/login
{
    "phone": "13838383388",
    "password": "123456",
    "tenant_code": "default"
}
→ 根据 tenant_code 查询租户信息（tenant_system.tenant）
→ 切换到租户库查询用户（mule_{tenantID}.admin）
→ 返回 JWT（tenant_id = "xxx"）
```

## 数据隔离保证

1. **物理隔离**：每个租户数据存储在独立数据库中
2. **自动切换**：通过 Context + DatabaseManager 自动切换数据库
3. **无需过滤**：Repository 查询时不需要添加 tenant_id 过滤条件
4. **安全性高**：租户之间物理隔离，即使代码有漏洞也无法跨租户访问

## 优势

1. **完全物理隔离**：最高级别的数据安全
2. **性能独立**：租户之间互不影响
3. **灵活扩展**：可以为大客户单独部署数据库服务器
4. **简化查询**：Repository 不需要考虑 tenant_id 过滤
5. **便于迁移**：整库迁移即可

## 当前状态

✅ **完整实现**：
- Context 传递机制
- DatabaseManager 自动切换
- 所有 Repository 支持多租户
- Auth 服务优化（直接查询 Role）
- Menu 管理系统级别统一
- 租户创建自动建库建表
- 登录支持租户选择

✅ **编译通过**：所有代码正常编译

✅ **功能可用**：登录、权限查询、菜单管理等核心功能已验证

## 下一步建议

1. **功能测试**：测试租户创建、登录、权限等核心功能
2. **性能测试**：测试多租户并发场景
3. **业务开发**：基于当前架构开发具体业务功能
4. **监控部署**：添加监控和日志，准备生产部署

