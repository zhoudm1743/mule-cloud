# 超管切换租户功能完整修复方案

## 问题总结

超管通过租户选择器切换租户后，遇到三个连环问题：

1. ❌ **数据库未正常获取** - 后端 Service 层问题
2. ❌ **页面跳转登录页** - 前端时序问题  
3. ❌ **网关未转发header** - 网关配置问题
4. ❌ **auth服务返回"用户不存在"** - 用户查询问题 ← 最新发现

## 问题详细分析

### 问题 1：后端 Service 层丢失 Context

**原因：** Service 方法使用 `context.Background()` 创建新的上下文

**修复：** 
- 修改所有 Service 接口和实现，添加 `ctx context.Context` 参数
- 在 Repository 中添加 `GetCollectionWithContext(ctx)` 方法

**修改文件：**
- `app/perms/services/admin.go`
- `app/perms/endpoint/admin.go`
- `internal/repository/admin.go`
- `core/database/manager.go`
- `app/perms/services/tenant.go`

### 问题 2：前端 HTTP 拦截器时序问题

**原因：** 页面刷新后，`userInfo` 未加载，条件判断失败

**修复：** 简化拦截器逻辑，只检查 `selected_tenant_code`

**修改文件：**
- `frontend/src/service/http/alova.ts`

### 问题 3：网关未转发 X-Tenant-Context Header

**原因：** 网关只转发从 JWT 解析的 headers，没有转发前端直接发送的 `X-Tenant-Context`

**修复：** 在网关代理逻辑中添加 header 转发

```go
// ✅ 重要：转发前端发送的 X-Tenant-Context header
if contextTenant := c.GetHeader("X-Tenant-Context"); contextTenant != "" {
    c.Request.Header.Set("X-Tenant-Context", contextTenant)
    log.Printf("[网关转发] 转发租户上下文: %s", contextTenant)
}
```

**修改文件：**
- `cmd/gateway/main.go`

### 问题 4：auth服务的GetUserRoutes查询用户失败

**原因：** 
1. 前端发送 `X-Tenant-Context: ace`
2. auth服务的 `TenantContextMiddleware` 切换了租户上下文到 "ace"
3. `GetUserRoutes` 方法在 "ace" 租户数据库中查询系统管理员
4. 但系统管理员存储在系统数据库中
5. 返回"用户不存在"

**核心问题：** `X-Tenant-Context` 应该只影响**数据查询视图**（查询管理员列表等），不应该影响**用户身份验证**（查询当前用户信息）。

**修复：** 在 `GetUserRoutes` 方法中，通过角色判断是否为超管，如果是超管，强制使用系统库查询用户信息。

```go
// 检查是否是系统管理员（通过角色判断）
roles := tenantCtx.GetRoles(ctx)
isSuperAdmin := false
for _, role := range roles {
    if role == "super" {
        isSuperAdmin = true
        break
    }
}

// 如果是系统管理员，强制使用系统库（空字符串）
queryCtx := ctx
if isSuperAdmin {
    queryCtx = tenantCtx.WithTenantCode(context.Background(), "")
}

// 获取用户信息（从用户自己的租户数据库）
admin, err := s.repo.Get(queryCtx, userID)
```

**修改文件：**
- `app/auth/services/auth.go`

## 数据流完整分析

### 场景：超管切换到租户 "ace"

#### 1. 用户操作
```
超管选择租户 "ace" → 保存到 localStorage → 页面刷新
```

#### 2. 页面刷新后的请求流程

##### 请求 1：获取租户列表（不受影响）
```
GET /admin/perms/tenants/all
Headers:
  Authorization: Bearer xxx
  X-Tenant-Context: ace  ← 前端发送，但此接口不受影响
  
→ 网关转发到 perms服务
→ perms 查询系统数据库（tenants存储在系统库）
→ 返回所有租户 ✅
```

##### 请求 2：获取用户路由（❌ 问题点）
```
GET /admin/auth/getUserRoutes
Headers:
  Authorization: Bearer xxx (tenantCode="system")
  X-Tenant-Context: ace  ← 前端发送

→ 网关接收（修复前：不转发此header ❌）
→ 网关接收（修复后：转发此header ✅）

→ auth服务接收
  - GatewayOrJWTAuth: 解析JWT → tenantCode="system"
  - TenantContextMiddleware: 检查X-Tenant-Context="ace"
    * currentTenantCode="system" ✅
    * isSuperAdmin=true ✅
    * 切换：ctx.WithTenantCode("ace")
  
→ GetUserRoutes 方法
  - 修复前：ctx.tenantCode="ace" → 在ace数据库查询 → 用户不存在 ❌
  - 修复后：检测到isSuperAdmin → 强制使用系统库 → 查询成功 ✅
  
→ 返回用户路由 ✅
```

##### 请求 3：获取管理员列表（正常工作）
```
GET /admin/perms/admins?page=1&page_size=10
Headers:
  Authorization: Bearer xxx
  X-Tenant-Context: ace

→ 网关转发（包含X-Tenant-Context）
→ perms服务
  - GatewayOrJWTAuth: tenantCode="system"
  - TenantContextMiddleware: 切换到tenantCode="ace"
→ AdminService.List(ctx)
  - 使用传入的ctx（tenantCode="ace"）
  - 查询 mule_ace 数据库 ✅
→ 返回ace租户的管理员列表 ✅
```

## 核心设计原则

### 1. X-Tenant-Context 的作用域

`X-Tenant-Context` header 应该只影响**数据查询**接口，不应该影响**用户身份**接口：

| 接口类型 | 是否受影响 | 原因 |
|---------|----------|------|
| 获取管理员列表 | ✅ 是 | 数据查询，应该查询指定租户的数据 |
| 获取角色列表 | ✅ 是 | 数据查询，应该查询指定租户的数据 |
| 创建管理员 | ✅ 是 | 数据操作，应该在指定租户中创建 |
| **获取当前用户信息** | ❌ 否 | 用户身份，应该从用户所属租户查询 |
| **获取用户路由** | ❌ 否 | 用户身份，应该从用户所属租户查询 |
| **获取用户权限** | ❌ 否 | 用户身份，应该从用户所属租户查询 |

### 2. 中间件执行顺序

```
请求 → CORS
    → GatewayOrJWTAuth（解析JWT，设置原始tenantCode）
    → TenantContextMiddleware（检查X-Tenant-Context，可能切换tenantCode）
    → 业务处理器
```

### 3. 两个租户代码的区别

- **JWT中的tenantCode**：用户所属的租户（不会变）
  - 系统管理员：`"system"`
  - 租户管理员：`"ace"`

- **X-Tenant-Context**：用户想查看的租户（可切换）
  - 只有超管可以使用
  - 用于切换数据查询视图

## 修改文件清单

### 后端（6个文件）

1. `app/perms/services/admin.go` - Service 接口和实现（Context传递）
2. `app/perms/endpoint/admin.go` - Endpoint 层（Context传递）
3. `internal/repository/admin.go` - Repository 层（添加Context方法）
4. `core/database/manager.go` - 数据库管理器（处理"system"）
5. `app/perms/services/tenant.go` - 租户服务（更新调用）
6. **`app/auth/services/auth.go`** - Auth 服务（修复GetUserRoutes）← 新增
7. **`cmd/gateway/main.go`** - 网关服务（转发header）← 新增

### 前端（1个文件）

8. `frontend/src/service/http/alova.ts` - HTTP 拦截器（简化逻辑）

### 文档（5个文件）

9. `docs/修复-超管切换租户数据库问题.md` - 后端Context问题
10. `docs/修复-超管切换租户前端问题.md` - 前端时序问题
11. `docs/修复-网关未转发租户上下文header.md` - 网关转发问题
12. `docs/测试-超管切换租户功能.md` - 测试指南
13. `docs/超管切换租户完整修复总结.md` - 完整总结
14. **`docs/修复-超管切换租户完整方案.md`** - 最终方案 ← 本文档

## 编译服务

```bash
# 编译网关
cd cmd/gateway
go build -o gateway.exe

# 编译 perms 服务  
cd cmd/perms
go build -o perms.exe

# 编译 auth 服务
cd cmd/auth
go build -o auth.exe
```

## 测试验证

### 1. 重启所有服务

```bash
# 停止旧进程
# 启动网关
cd cmd/gateway
./gateway.exe

# 启动 auth 服务
cd cmd/auth
./auth.exe

# 启动 perms 服务
cd cmd/perms
./perms.exe
```

### 2. 前端测试

1. 以系统管理员身份登录
2. 选择租户 "ace"
3. 页面应该正常刷新（不跳转登录页）✅
4. 可以查看 ace 租户的管理员列表 ✅

### 3. 查看日志

**网关日志：**
```
[网关转发] 转发租户上下文: ace
```

**auth服务日志：**
```
（不应该有"用户不存在"错误）
```

**perms服务日志：**
```
[租户上下文切换] ✅ 系统管理员切换到租户: ace
[MongoDB] 执行命令: ... "$db": "mule_ace"}
```

## 经验教训

### 1. 数据查询 vs 用户身份

在设计多租户系统时，要区分：
- **数据查询接口**：应该支持租户切换（查看不同租户的数据）
- **用户身份接口**：不应该受租户切换影响（始终查询用户自己的信息）

### 2. 中间件的副作用

中间件修改 Context 是有副作用的，可能影响下游的所有逻辑。设计时要考虑：
- 哪些接口应该受影响？
- 哪些接口不应该受影响？
- 如何让某些接口"免疫"中间件的影响？

### 3. 网关作为透明代理

网关应该尽可能透明地转发请求，不要做过多的业务逻辑判断。对于业务相关的 headers，要明确配置是否转发。

### 4. 前端和后端的信任边界

- 前端可以发送任何 header，但后端必须验证
- 安全验证永远在后端，前端的检查只是 UX 优化
- 不要假设前端的数据是可信的

## 后续优化建议

### 1. 添加专门的中间件配置

为不同类型的接口提供不同的中间件配置：

```go
// 数据查询接口：支持租户切换
middleware.Apply(dataRoutes, jwtManager, middleware.MiddlewareConfig{
    SupportTenantSwitch: true,
})

// 用户身份接口：不支持租户切换  
middleware.Apply(authRoutes, jwtManager, middleware.MiddlewareConfig{
    SupportTenantSwitch: false,
})
```

### 2. 添加更详细的日志

在关键点添加日志，方便排查问题：
- 中间件切换租户时
- 网关转发 header 时
- Service 查询数据库时

### 3. 添加单元测试

测试关键场景：
- 超管切换租户后查询数据
- 超管切换租户后获取自己的信息
- 普通用户尝试切换租户

### 4. 前端不刷新页面切换租户

使用 Vue Router 和状态管理，不需要 `window.location.reload()`，提升用户体验。

## 总结

经过四个问题的修复，超管切换租户功能现在应该完全正常了：

1. ✅ Context 正确传递到整个调用链
2. ✅ 前端正确发送 `X-Tenant-Context` header  
3. ✅ 网关正确转发 `X-Tenant-Context` header
4. ✅ auth服务正确处理用户身份查询（不受租户切换影响）

现在超管可以：
- 在租户选择器中选择任何租户
- 查看该租户的数据（管理员、角色等）
- 在该租户中创建、修改、删除数据
- 随时切换回系统视图或其他租户
- 自己的用户信息和权限不受影响

