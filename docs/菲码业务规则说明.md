# 菲码业务规则说明

## 一、什么是菲码？

菲码是服装生产中用于标识和追踪裁片的二维码标签。

## 二、核心业务规则

### ⚠️ 关键原则

**一个菲码 = 一个扎号 + 一个颜色 + 一个尺码 + 该尺码在这个扎中的件数**

### 示例

| 扎号 | 颜色 | 尺码 | 数量 | 说明 |
|------|------|------|------|------|
| 01 | 红色 | S | 30件 | 一个菲码 |
| 01 | 红色 | M | 40件 | 另一个菲码 |
| 01 | 红色 | L | 50件 | 又一个菲码 |
| 02 | 绿色 | L | 1件 | 独立的菲码 |

**说明**：
- 扎号01虽然是同一扎，但因为有3个尺码，所以需要**3个菲码**
- 每个菲码独立标识一个尺码的裁片
- 工人上报时，扫哪个菲码就上报哪个尺码的数量

## 三、菲码JSON格式

```json
{
  "batch_id": "批次ID（MongoDB ObjectID）",
  "bed_no": "床号",
  "bundle_no": "扎号（格式化为2位数，如01、02）",
  "color": "颜色名称",
  "size": "尺码名称",
  "quantity": "该尺码在这个扎中的件数"
}
```

### 示例数据

```json
{
  "batch_id": "63f8a1b2c3d4e5f678901234",
  "bed_no": "1",
  "bundle_no": "01",
  "color": "红色",
  "size": "L",
  "quantity": 50
}
```

## 四、代码实现

### 4.1 单个批次创建（CreateCuttingBatch）

- **限制**：只能传入一个尺码
- **原因**：一个菲码只能代表一个尺码
- **建议**：如需创建多个尺码，请使用批量创建接口

```go
// ⚠️ 如果传入多个尺码会报错
if len(req.SizeDetails) > 1 {
    return nil, fmt.Errorf("单个批次创建只支持一个尺码，如需创建多个尺码请使用批量创建接口")
}
```

### 4.2 批量创建（BulkCreateCuttingBatch）

- 自动为每个尺码创建独立的批次和菲码
- 自动分配扎号（递增）
- 支持按层数拆分

**逻辑**：
```go
// 遍历每一行（每个颜色）
for _, batchItem := range req.Batches {
    // 遍历每个尺码
    for _, sizeDetail := range batchItem.SizeDetails {
        // 按层数创建多个扎号
        for layer := 0; layer < actualLayers; layer++ {
            // 每个扎号创建一个批次（一个菲码）
            // batch_id, bed_no, bundle_no, color, size, quantity
        }
    }
}
```

## 五、上报流程

### 5.1 扫码识别

1. 工人扫描菲码
2. 小程序发送二维码JSON到后端 `/production/scan/parse`
3. 后端通过 `batch_id` 查找批次
4. 返回批次信息（扎号、颜色、尺码、数量）和订单信息（工序列表）

### 5.2 工序上报

1. 工人选择工序
2. 提交上报，包含 `batch_id`
3. 后端通过 `batch_id` 获取完整批次信息
4. 自动填充颜色、尺码、数量等字段
5. 记录上报数据，更新进度

### 5.3 数据准确性保障

- ✅ 使用 `batch_id` 作为唯一标识
- ✅ 后端自动从批次获取准确的数量、颜色、尺码
- ✅ 防止数量超限（已上报 + 本次上报 ≤ 批次总量）
- ✅ 防止重复上报（批次工序进度已完成时提示）

## 六、修复的问题

### 问题描述

**旧版 `CreateCuttingBatch` 的BUG**：
```go
// ❌ 错误：把所有尺码的数量加总了
totalPieces := 0
for _, size := range req.SizeDetails {
    totalPieces += size.Quantity * req.LayerCount
}

// ❌ 错误：但二维码只保存了第一个尺码
var sizeValue string
if len(req.SizeDetails) > 0 {
    sizeValue = req.SizeDetails[0].Size
}
```

**导致的问题**：
- 扎号1，红色，L码，显示数量100件
- 但实际L码可能只有50件
- 100是 S(30) + M(40) + L(50) 的总和

### 修复方案

**新版 `CreateCuttingBatch`**：
```go
// ✅ 限制只能传入一个尺码
if len(req.SizeDetails) > 1 {
    return nil, fmt.Errorf("单个批次创建只支持一个尺码")
}

// ✅ 只处理一个尺码
sizeDetail := req.SizeDetails[0]
totalPieces := sizeDetail.Quantity * req.LayerCount
```

## 七、最佳实践

### 7.1 创建批次建议

- **优先使用批量创建接口** (`BulkCreateCuttingBatch`)
- 批量创建会自动为每个尺码创建独立批次
- 自动分配扎号，避免手动管理

### 7.2 前端展示建议

在裁剪批次列表中，清晰显示：
```
扎号01 - 红色 - S码 - 30件
扎号02 - 红色 - M码 - 40件
扎号03 - 红色 - L码 - 50件
```

而不是：
```
扎号01 - 红色 - S/M/L - 120件 ❌
```

### 7.3 打印菲码建议

- 每个批次打印一个菲码
- 菲码上标注：扎号、颜色、尺码、数量
- 建议格式：`01 | 红色 | L | 50件`

## 八、数据库设计

### CuttingBatch（裁剪批次）

```go
type CuttingBatch struct {
    ID          string       // 批次ID（唯一）
    BundleNo    string       // 扎号
    Color       string       // 颜色
    SizeDetails []SizeDetail // 尺码明细（应该只有一个）
    TotalPieces int          // 总件数
    QRCode      string       // 二维码JSON
    // ...其他字段
}
```

**重要**：虽然 `SizeDetails` 是数组，但在新的业务规则下，每个批次应该只包含一个尺码。

## 九、更新日志

### 2025年10月19日

1. **修复** `CreateCuttingBatch` 方法
   - 限制只能传入一个尺码
   - 修正数量计算逻辑
   - 确保二维码数据与实际批次一致

2. **保持** `BulkCreateCuttingBatch` 逻辑不变
   - 该方法已正确实现一个尺码一个批次

3. **优化**菲码JSON格式
   - 使用 `batch_id` 作为唯一标识
   - 简化字段，只保留核心信息

4. **文档**更新
   - 明确菲码业务规则
   - 提供最佳实践建议

