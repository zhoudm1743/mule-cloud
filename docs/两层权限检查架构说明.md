# 两层权限检查架构说明

## 🤔 问题背景

**用户疑问**：当前 Casbin 通过 `path + action` 来匹配权限，但自定义业务权限（如"挂账"、"核销"）没有对应的独立 HTTP 路径，Casbin 怎么判断？

## ✅ 正确答案：两层检查架构

### 架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      Gateway 层                              │
│  ┌────────────────────────────────────────────────────┐     │
│  │  Casbin 中间件 (casbin_auth.go)                   │     │
│  │  - 拦截所有 HTTP 请求                              │     │
│  │  - 提取 path + method                              │     │
│  │  - 映射: GET→read, POST→create, PUT→update         │     │
│  │  - 检查: 用户能否访问这个路径                      │     │
│  └────────────────────────────────────────────────────┘     │
│               ↓ 通过基础检查                                 │
└─────────────────────────────────────────────────────────────┘
                ↓
┌─────────────────────────────────────────────────────────────┐
│                    业务服务层                                │
│  ┌────────────────────────────────────────────────────┐     │
│  │  业务逻辑代码 (services/*.go)                      │     │
│  │  - 根据具体业务操作                                │     │
│  │  - 调用 casbin.CheckUserPermission()               │     │
│  │  - 检查: 用户能否执行特定业务动作（pending/verify）│     │
│  └────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────┘
```

## 📊 第一层：Gateway HTTP 层面检查

### Gateway 的 Casbin 中间件

```go
// app/gateway/middleware/casbin_auth.go

func getActionFromMethod(method string) string {
    switch strings.ToUpper(method) {
    case "GET", "HEAD":   return "read"
    case "POST":          return "create"
    case "PUT", "PATCH":  return "update"
    case "DELETE":        return "delete"
    default:              return "read"
    }
}

// 权限检查
resource := "/finance/order"           // 请求路径
action := getActionFromMethod("POST")  // POST → "create"
allowed, err = casbin.CheckPermission(userSub, resource, action)
```

### 这一层的作用

✅ **检查内容**：用户能否访问这个 HTTP 路径
- `GET /finance/order` → 检查 `read` 权限
- `POST /finance/order` → 检查 `create` 权限
- `PUT /finance/order/:id` → 检查 `update` 权限
- `DELETE /finance/order/:id` → 检查 `delete` 权限

❌ **无法检查**：具体的业务操作（挂账、核销、审核等）

### 为什么无法检查业务操作？

因为所有业务操作可能都是 **相同的 HTTP 请求**：

```bash
# 创建订单
POST /finance/order
Body: { "amount": 100, "customer": "张三" }

# 挂账操作
POST /finance/order/action
Body: { "action": "pending", "orderId": "123" }

# 核销操作  
POST /finance/order/action
Body: { "action": "verify", "orderId": "123" }
```

Gateway 只能看到：
- Method: `POST`
- Path: `/finance/order/action`
- Action: `create` (因为是 POST)

Gateway **无法区分**这是"挂账"还是"核销"，因为它们都是 POST 请求！

## 📊 第二层：业务代码层面检查

### 在业务逻辑中手动检查

```go
// app/finance/services/order.go

import "mule-cloud/core/casbin"

type OrderService struct {
    // ...
}

// HandleOrderAction 处理订单操作
func (s *OrderService) HandleOrderAction(ctx context.Context, userID, tenantID, action, orderID string) error {
    // 第一步：根据 action 确定需要的权限
    var requiredPermission string
    switch action {
    case "pending":
        requiredPermission = "pending"  // 挂账权限
    case "verify":
        requiredPermission = "verify"   // 核销权限
    case "audit":
        requiredPermission = "audit"    // 审核权限
    default:
        return fmt.Errorf("未知操作: %s", action)
    }
    
    // 第二步：检查用户是否有这个业务权限
    hasPermission := casbin.CheckUserPermission(tenantID, userID, "/finance", requiredPermission)
    if !hasPermission {
        log.Printf("[权限拒绝] 用户 %s 无 %s 权限", userID, requiredPermission)
        return fmt.Errorf("无%s权限", requiredPermission)
    }
    
    // 第三步：执行业务逻辑
    switch action {
    case "pending":
        return s.pendingOrder(ctx, orderID)
    case "verify":
        return s.verifyOrder(ctx, orderID)
    case "audit":
        return s.auditOrder(ctx, orderID)
    }
    
    return nil
}

func (s *OrderService) pendingOrder(ctx context.Context, orderID string) error {
    log.Printf("执行挂账逻辑: %s", orderID)
    // 更新订单状态为挂账...
    return nil
}

func (s *OrderService) verifyOrder(ctx context.Context, orderID string) error {
    log.Printf("执行核销逻辑: %s", orderID)
    // 更新订单状态为已核销...
    return nil
}
```

### 完整请求流程

```
1. 用户发起请求
   POST /admin/finance/order/action
   Body: { "action": "pending", "orderId": "123" }
   ↓

2. Gateway Casbin 中间件 ✅
   - 检查: POST /admin/finance/order/action → "create" 权限
   - 用户有 "create" 权限 → 放行
   ↓

3. 路由到 OrderService.HandleOrderAction() ✅
   - 解析 action = "pending"
   - 调用 casbin.CheckUserPermission(tenantID, userID, "/finance", "pending")
   - 用户有 "pending" 权限 → 执行挂账逻辑
   ↓

4. 返回成功
```

## 🎯 关键点总结

### 1. Gateway 层的 Casbin 策略

```
tenant:A:user:user1, /finance, read
tenant:A:user:user1, /finance, create
tenant:A:user:user1, /finance, update
tenant:A:user:user1, /finance, pending  ← 自定义业务权限也存储在 Casbin！
tenant:A:user:user1, /finance, verify   ← 自定义业务权限也存储在 Casbin！
```

- Gateway 中间件**只检查 HTTP 层面**的权限（read/create/update/delete）
- 但 Casbin 数据库中**存储了所有权限**（包括 pending/verify）
- 业务代码可以通过 `casbin.CheckUserPermission()` **手动查询**这些权限

### 2. 为什么要这样设计？

#### ✅ 优点

1. **解耦合**：Gateway 负责 HTTP 层，业务代码负责业务逻辑
2. **灵活性**：业务权限可以自由定义，不受 HTTP 方法限制
3. **安全性**：双重检查，更加安全
4. **可扩展**：新增业务权限不需要修改 Gateway

#### ❌ 如果只依赖 Gateway？

假设要在 Gateway 检查"挂账"权限，需要：
- 为每个业务操作创建独立路由：`POST /finance/pending`, `POST /finance/verify`
- 或者自定义 HTTP 头：`X-Business-Action: pending`
- 都不够优雅！

## 📝 代码示例合集

### 示例 1：财务订单挂账

```go
// app/finance/transport/order.go

func HandleOrderActionHandler(orderSvc *services.OrderService) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID := c.GetString("userID")
        tenantID := c.GetString("tenantID")
        
        var req struct {
            Action  string `json:"action" binding:"required"`
            OrderID string `json:"orderId" binding:"required"`
        }
        
        if err := c.ShouldBindJSON(&req); err != nil {
            response.Error(c, "参数错误")
            return
        }
        
        // 调用 service 层，service 层会检查权限
        err := orderSvc.HandleOrderAction(c.Request.Context(), userID, tenantID, req.Action, req.OrderID)
        if err != nil {
            response.Error(c, err.Error())
            return
        }
        
        response.SuccessWithMsg(c, "操作成功", nil)
    }
}
```

### 示例 2：工作流审批

```go
// app/workflow/services/approval.go

func (s *ApprovalService) ApproveTask(ctx context.Context, userID, tenantID, taskID string) error {
    // 检查审批权限
    hasPermission := casbin.CheckUserPermission(tenantID, userID, "/workflow", "approve")
    if !hasPermission {
        return fmt.Errorf("无审批权限")
    }
    
    // 执行审批逻辑
    return s.repo.UpdateTaskStatus(ctx, taskID, "approved", userID)
}

func (s *ApprovalService) RejectTask(ctx context.Context, userID, tenantID, taskID string) error {
    // 检查驳回权限
    hasPermission := casbin.CheckUserPermission(tenantID, userID, "/workflow", "reject")
    if !hasPermission {
        return fmt.Errorf("无驳回权限")
    }
    
    // 执行驳回逻辑
    return s.repo.UpdateTaskStatus(ctx, taskID, "rejected", userID)
}
```

### 示例 3：数据导出

```go
// app/report/services/export.go

func (s *ReportService) ExportData(ctx context.Context, userID, tenantID, reportType string) ([]byte, error) {
    // 检查导出权限
    hasPermission := casbin.CheckUserPermission(tenantID, userID, "/report", "export")
    if !hasPermission {
        return nil, fmt.Errorf("无导出权限")
    }
    
    // 执行导出逻辑
    return s.generateExcel(ctx, reportType)
}
```

## 🔗 权限同步机制

### 权限是如何存储到 Casbin 的？

```go
// app/system/services/role.go

func (s *RoleService) AssignMenus(ctx context.Context, roleID string, menuNames []string, menuPermissions map[string][]string, updatedBy string) error {
    // 1. 更新数据库
    updates := map[string]interface{}{
        "menus":            menuNames,
        "menu_permissions": menuPermissions,  // {"finance": ["read", "create", "pending", "verify"]}
    }
    err = s.roleRepo.Update(ctx, roleID, updates)
    
    // 2. 同步到 Casbin（包括自定义权限！）
    menuPathMap := make(map[string]string)
    for _, menuName := range menuNames {
        menu, _ := s.menuRepo.GetByName(ctx, menuName)
        menuPathMap[menuName] = menu.Path  // {"finance": "/finance"}
    }
    
    // 这里会把所有权限（read/create/pending/verify）都写入 Casbin！
    err = casbin.SyncRoleMenusWithPermissions(role.TenantID, roleID, menuPermissions, menuPathMap)
    
    return nil
}
```

### Casbin 策略表内容

```
p, tenant:A:role:role1, /finance, read
p, tenant:A:role:role1, /finance, create
p, tenant:A:role:role1, /finance, update
p, tenant:A:role:role1, /finance, delete
p, tenant:A:role:role1, /finance, pending   ← 自定义权限在这里！
p, tenant:A:role:role1, /finance, verify    ← 自定义权限在这里！

g, tenant:A:user:user1, tenant:A:role:role1
```

## ⚠️ 注意事项

### 1. 业务代码必须手动检查权限

❌ **错误示例**（没有检查权限）：
```go
func (s *OrderService) PendingOrder(ctx context.Context, orderID string) error {
    // 直接执行业务逻辑 - 危险！
    return s.updateOrderStatus(ctx, orderID, "pending")
}
```

✅ **正确示例**（先检查权限）：
```go
func (s *OrderService) PendingOrder(ctx context.Context, userID, tenantID, orderID string) error {
    // 先检查权限
    if !casbin.CheckUserPermission(tenantID, userID, "/finance", "pending") {
        return fmt.Errorf("无挂账权限")
    }
    
    // 再执行业务逻辑
    return s.updateOrderStatus(ctx, orderID, "pending")
}
```

### 2. 权限命名规范

| 权限类型 | Action 示例 | 说明 |
|---------|-------------|------|
| 基础权限 | read, create, update, delete | HTTP 方法映射 |
| 业务权限 | pending, verify, approve, reject, export | 自定义业务操作 |

### 3. 前端权限控制

前端使用 `hasAction` 控制按钮显示：

```vue
<script setup lang="ts">
import { usePermission } from '@/hooks'

const { hasAction } = usePermission()
</script>

<template>
  <!-- 基础权限 -->
  <NButton v-if="hasAction('finance', 'create')" @click="handleCreate">
    新建订单
  </NButton>
  
  <!-- 业务权限 -->
  <NButton v-if="hasAction('finance', 'pending')" @click="handlePending">
    挂账
  </NButton>
  
  <NButton v-if="hasAction('finance', 'verify')" @click="handleVerify">
    核销
  </NButton>
</template>
```

## 🎉 总结

| 层级 | 检查内容 | 检查方式 | 作用 |
|-----|---------|---------|------|
| Gateway 层 | HTTP 访问权限 | Casbin 中间件自动检查 | 粗粒度拦截，防止未授权访问 |
| 业务代码层 | 业务操作权限 | 手动调用 `casbin.CheckUserPermission()` | 细粒度控制，确保业务安全 |

**核心思想**：
- Gateway 负责 **"能不能进来"**
- 业务代码负责 **"能不能做这个操作"**
- 两层检查，双重保障！🔒

