# 数据库级别租户隔离改造方案

## 📋 目录
- [1. 改造目标](#1-改造目标)
- [2. 架构对比](#2-架构对比)
- [3. 核心设计](#3-核心设计)
- [4. 详细改造步骤](#4-详细改造步骤)
- [5. 代码改造清单](#5-代码改造清单)
- [6. 风险评估](#6-风险评估)
- [7. 数据迁移方案](#7-数据迁移方案)
- [8. 测试计划](#8-测试计划)

---

## 1. 改造目标

### 1.1 主要目标
- ✅ **物理隔离**：每个租户使用独立的MongoDB数据库，实现物理级别的数据隔离
- ✅ **简化模型**：移除所有模型中的 `tenant_id` 字段，简化数据结构
- ✅ **动态切换**：在鉴权阶段根据JWT Token中的租户信息自动切换数据库
- ✅ **自动创建**：租户创建时自动创建独立数据库
- ✅ **安全性**：防止租户间数据泄露和越权访问

### 1.2 预期收益
- ✅ **安全性提升**：物理隔离杜绝逻辑隔离的潜在风险
- ✅ **代码简化**：无需在每个查询中手动添加 `tenant_id` 过滤
- ✅ **扩展性增强**：便于单租户数据库迁移和备份
- ✅ **性能优化**：租户数据分散，单库压力降低
- ✅ **故障隔离**：单个租户数据库问题不影响其他租户

---

## 2. 架构对比

### 2.1 现有架构（逻辑隔离）

```
┌────────────────────────────────────────────┐
│        MongoDB: mule (单一数据库)          │
├────────────────────────────────────────────┤
│  Collection: admin                         │
│  ├─ { _id, tenant_id: "A", ... }          │
│  ├─ { _id, tenant_id: "B", ... }          │
│  └─ { _id, tenant_id: "C", ... }          │
├────────────────────────────────────────────┤
│  Collection: basic                         │
│  ├─ { _id, tenant_id: "A", ... }          │
│  └─ { _id, tenant_id: "B", ... }          │
└────────────────────────────────────────────┘

数据查询：filter := bson.M{"tenant_id": tenantID, ...}
```

**问题：**
- ❌ 代码中需要到处添加 `tenant_id` 过滤
- ❌ 容易遗漏过滤条件导致数据泄露
- ❌ 租户数据混在一起，备份和迁移不便
- ❌ 单库压力大，性能瓶颈

### 2.2 新架构（物理隔离）

```
┌─────────────────────────────┐
│  MongoDB Server             │
├─────────────────────────────┤
│  Database: tenant_system    │  ← 系统库（租户管理）
│  ├─ Collection: tenant      │
│  └─ Collection: admin (超管)│
├─────────────────────────────┤
│  Database: tenant_A         │  ← 租户A独立库
│  ├─ Collection: admin       │
│  ├─ Collection: role        │
│  ├─ Collection: menu        │
│  └─ Collection: basic       │
├─────────────────────────────┤
│  Database: tenant_B         │  ← 租户B独立库
│  ├─ Collection: admin       │
│  ├─ Collection: role        │
│  ├─ Collection: menu        │
│  └─ Collection: basic       │
└─────────────────────────────┘

数据查询：自动使用租户对应的数据库，无需 tenant_id 过滤
```

**优势：**
- ✅ 物理隔离，安全性高
- ✅ 代码简化，无需 tenant_id
- ✅ 独立备份和迁移
- ✅ 性能分散，无单点瓶颈

---

## 3. 核心设计

### 3.1 数据库命名规范

```go
// 系统数据库（存储租户元数据和系统超管）
const SystemDatabase = "tenant_system"

// 租户数据库命名规则
func GetTenantDatabase(tenantID string) string {
    return fmt.Sprintf("tenant_%s", tenantID)
}
```

**示例：**
- 系统库：`tenant_system`
- 租户A库：`tenant_68dd0...`
- 租户B库：`tenant_68dd1...`

### 3.2 数据库连接池管理

```go
// DatabaseManager 数据库管理器
type DatabaseManager struct {
    client      *mongo.Client
    systemDB    *mongo.Database
    tenantDBs   sync.Map // map[tenantID]*mongo.Database
}

// GetDatabase 根据租户ID获取数据库（自动创建连接）
func (m *DatabaseManager) GetDatabase(tenantID string) *mongo.Database {
    if tenantID == "" {
        return m.systemDB // 系统超管使用系统库
    }
    
    // 尝试从缓存获取
    if db, ok := m.tenantDBs.Load(tenantID); ok {
        return db.(*mongo.Database)
    }
    
    // 创建新的数据库连接
    dbName := GetTenantDatabase(tenantID)
    db := m.client.Database(dbName)
    m.tenantDBs.Store(tenantID, db)
    
    return db
}
```

### 3.3 Context传递租户信息

```go
// Context Key
type contextKey string
const TenantIDKey contextKey = "tenant_id"

// 中间件设置租户ID
func JWTAuth(jwtManager *jwt.JWTManager) gin.HandlerFunc {
    return func(c *gin.Context) {
        // ... JWT验证 ...
        
        // 将租户ID存入Context（Gin和标准Context）
        c.Set("tenant_id", claims.TenantID)
        ctx := context.WithValue(c.Request.Context(), TenantIDKey, claims.TenantID)
        c.Request = c.Request.WithContext(ctx)
        
        c.Next()
    }
}

// 从Context获取租户ID
func GetTenantIDFromContext(ctx context.Context) string {
    if tenantID, ok := ctx.Value(TenantIDKey).(string); ok {
        return tenantID
    }
    return ""
}
```

### 3.4 Repository层自动切换数据库

```go
// AdminRepository 管理员数据仓库
type AdminRepository struct {
    dbManager *database.DatabaseManager
}

// Get 根据ID获取记录（自动使用租户数据库）
func (r *AdminRepository) Get(ctx context.Context, id string) (*models.Admin, error) {
    tenantID := GetTenantIDFromContext(ctx)
    db := r.dbManager.GetDatabase(tenantID)
    collection := db.Collection("admin")
    
    // 无需 tenant_id 过滤
    filter := bson.M{"_id": id, "is_deleted": 0}
    admin := &models.Admin{}
    err := collection.FindOne(ctx, filter).Decode(admin)
    // ...
}
```

---

## 4. 详细改造步骤

### 阶段一：核心基础设施改造（1-2天）

#### Step 1: 数据库管理器实现

**文件：** `core/database/manager.go` (新建)

```go
package database

import (
    "context"
    "fmt"
    "sync"
    "go.mongodb.org/mongo-driver/v2/mongo"
)

const SystemDatabase = "tenant_system"

// DatabaseManager 多租户数据库管理器
type DatabaseManager struct {
    client    *mongo.Client
    systemDB  *mongo.Database
    tenantDBs sync.Map // map[tenantID]*mongo.Database
    mu        sync.RWMutex
}

var (
    globalDBManager *DatabaseManager
    managerOnce     sync.Once
)

// InitDatabaseManager 初始化数据库管理器
func InitDatabaseManager(client *mongo.Client) *DatabaseManager {
    managerOnce.Do(func() {
        globalDBManager = &DatabaseManager{
            client:   client,
            systemDB: client.Database(SystemDatabase),
        }
    })
    return globalDBManager
}

// GetDatabaseManager 获取全局数据库管理器
func GetDatabaseManager() *DatabaseManager {
    return globalDBManager
}

// GetDatabase 获取租户数据库（空tenantID返回系统库）
func (m *DatabaseManager) GetDatabase(tenantID string) *mongo.Database {
    if tenantID == "" {
        return m.systemDB
    }
    
    // 从缓存获取
    if db, ok := m.tenantDBs.Load(tenantID); ok {
        return db.(*mongo.Database)
    }
    
    // 创建新连接
    dbName := GetTenantDatabaseName(tenantID)
    db := m.client.Database(dbName)
    m.tenantDBs.Store(tenantID, db)
    
    return db
}

// GetSystemDatabase 获取系统数据库
func (m *DatabaseManager) GetSystemDatabase() *mongo.Database {
    return m.systemDB
}

// CreateTenantDatabase 创建租户数据库（初始化集合和索引）
func (m *DatabaseManager) CreateTenantDatabase(ctx context.Context, tenantID string) error {
    dbName := GetTenantDatabaseName(tenantID)
    db := m.client.Database(dbName)
    
    // 创建集合和索引
    collections := []string{"admin", "role", "menu", "basic", "color", "customer", "order_type", "procedure", "salesman", "size"}
    
    for _, collName := range collections {
        // 创建集合（MongoDB会自动创建，这里显式创建以确保存在）
        err := db.CreateCollection(ctx, collName)
        if err != nil {
            // 忽略已存在错误
            if !mongo.IsDuplicateKeyError(err) {
                return fmt.Errorf("创建集合 %s 失败: %v", collName, err)
            }
        }
        
        // 创建常用索引
        collection := db.Collection(collName)
        
        // 创建 is_deleted 索引（软删除查询优化）
        _, err = collection.Indexes().CreateOne(ctx, mongo.IndexModel{
            Keys: bson.D{{Key: "is_deleted", Value: 1}},
        })
        if err != nil {
            return fmt.Errorf("创建索引失败: %v", err)
        }
        
        // admin 集合特殊索引
        if collName == "admin" {
            // 手机号唯一索引
            _, err = collection.Indexes().CreateOne(ctx, mongo.IndexModel{
                Keys:    bson.D{{Key: "phone", Value: 1}},
                Options: options.Index().SetUnique(true).SetSparse(true),
            })
            if err != nil {
                return fmt.Errorf("创建 phone 索引失败: %v", err)
            }
        }
    }
    
    // 缓存数据库连接
    m.tenantDBs.Store(tenantID, db)
    
    return nil
}

// DeleteTenantDatabase 删除租户数据库（谨慎操作）
func (m *DatabaseManager) DeleteTenantDatabase(ctx context.Context, tenantID string) error {
    dbName := GetTenantDatabaseName(tenantID)
    
    // 删除数据库
    err := m.client.Database(dbName).Drop(ctx)
    if err != nil {
        return fmt.Errorf("删除数据库失败: %v", err)
    }
    
    // 从缓存移除
    m.tenantDBs.Delete(tenantID)
    
    return nil
}

// GetTenantDatabaseName 获取租户数据库名称
func GetTenantDatabaseName(tenantID string) string {
    return fmt.Sprintf("tenant_%s", tenantID)
}

// ListTenantDatabases 列出所有租户数据库
func (m *DatabaseManager) ListTenantDatabases(ctx context.Context) ([]string, error) {
    databases, err := m.client.ListDatabaseNames(ctx, bson.M{})
    if err != nil {
        return nil, err
    }
    
    tenantDBs := []string{}
    for _, db := range databases {
        if strings.HasPrefix(db, "tenant_") && db != SystemDatabase {
            tenantDBs = append(tenantDBs, db)
        }
    }
    
    return tenantDBs, nil
}
```

#### Step 2: Context传递机制

**文件：** `core/context/tenant.go` (新建)

```go
package context

import (
    "context"
)

// Context Key
type contextKey string

const (
    TenantIDKey contextKey = "tenant_id"
    UserIDKey   contextKey = "user_id"
    UsernameKey contextKey = "username"
    RolesKey    contextKey = "roles"
)

// WithTenantID 设置租户ID到Context
func WithTenantID(ctx context.Context, tenantID string) context.Context {
    return context.WithValue(ctx, TenantIDKey, tenantID)
}

// GetTenantID 从Context获取租户ID
func GetTenantID(ctx context.Context) string {
    if tenantID, ok := ctx.Value(TenantIDKey).(string); ok {
        return tenantID
    }
    return ""
}

// WithUserInfo 设置用户信息到Context
func WithUserInfo(ctx context.Context, userID, username string, roles []string) context.Context {
    ctx = context.WithValue(ctx, UserIDKey, userID)
    ctx = context.WithValue(ctx, UsernameKey, username)
    ctx = context.WithValue(ctx, RolesKey, roles)
    return ctx
}

// GetUserID 从Context获取用户ID
func GetUserID(ctx context.Context) string {
    if userID, ok := ctx.Value(UserIDKey).(string); ok {
        return userID
    }
    return ""
}
```

#### Step 3: 网关中间件改造

**文件：** `app/gateway/middleware/auth.go`

```go
import (
    tenantCtx "mule-cloud/core/context"
)

// JWTAuth JWT认证中间件
func JWTAuth(jwtManager *jwt.JWTManager) gin.HandlerFunc {
    return func(c *gin.Context) {
        // ... JWT验证代码保持不变 ...
        
        // 将用户信息存入 Gin Context（保持兼容）
        c.Set("user_id", claims.UserID)
        c.Set("username", claims.Username)
        c.Set("tenant_id", claims.TenantID)
        c.Set("roles", claims.Roles)
        c.Set("claims", claims)
        
        // ✅ 新增：将租户信息存入标准Context
        ctx := c.Request.Context()
        ctx = tenantCtx.WithTenantID(ctx, claims.TenantID)
        ctx = tenantCtx.WithUserInfo(ctx, claims.UserID, claims.Username, claims.Roles)
        c.Request = c.Request.WithContext(ctx)
        
        c.Next()
    }
}
```

---

### 阶段二：模型和Repository层改造（2-3天）

#### Step 4: 移除所有模型中的 tenant_id 字段

**改造文件列表：**
- `internal/models/admin.go`
- `internal/models/basic.go`
- `internal/models/role.go`
- `internal/models/menu.go`

**示例改造：** `internal/models/admin.go`

```go
// Admin 管理员模型
type Admin struct {
    ID        string   `json:"id" bson:"_id,omitempty"`
    // ❌ 删除：TenantID  string   `json:"tenant_id" bson:"tenant_id"`
    Phone     string   `json:"phone" bson:"phone"`
    Password  string   `json:"-" bson:"password"`
    Nickname  string   `json:"nickname" bson:"nickname"`
    Email     string   `json:"email" bson:"email"`
    Avatar    string   `json:"avatar" bson:"avatar"`
    Roles     []string `json:"role" bson:"role"`
    Status    int      `json:"status" bson:"status"`
    IsDeleted int      `json:"is_deleted" bson:"is_deleted"`
    CreatedBy string   `json:"created_by" bson:"created_by"`
    UpdatedBy string   `json:"updated_by" bson:"updated_by"`
    CreatedAt int64    `json:"created_at" bson:"created_at"`
    UpdatedAt int64    `json:"updated_at" bson:"updated_at"`
    DeletedAt int64    `json:"deleted_at" bson:"deleted_at"`
}
```

#### Step 5: Repository层改造

**改造文件列表：**
- `internal/repository/admin.go`
- `internal/repository/basic.go`
- `internal/repository/role.go`
- `internal/repository/menu.go`
- `internal/repository/tenant.go`

**示例改造：** `internal/repository/admin.go`

```go
package repository

import (
    "context"
    "mule-cloud/core/database"
    tenantCtx "mule-cloud/core/context"
    "mule-cloud/internal/models"
)

// AdminRepository Admin数据仓库
type AdminRepository interface {
    Get(ctx context.Context, id string) (*models.Admin, error)
    // ... 其他方法 ...
}

// adminRepository 实现
type adminRepository struct {
    dbManager *database.DatabaseManager
}

// NewAdminRepository 创建仓库实例
func NewAdminRepository() AdminRepository {
    return &adminRepository{
        dbManager: database.GetDatabaseManager(),
    }
}

// getCollection 获取集合（自动根据Context中的租户ID切换数据库）
func (r *adminRepository) getCollection(ctx context.Context) *mongo.Collection {
    tenantID := tenantCtx.GetTenantID(ctx)
    db := r.dbManager.GetDatabase(tenantID)
    return db.Collection("admin")
}

// Get 获取单条记录
func (r *adminRepository) Get(ctx context.Context, id string) (*models.Admin, error) {
    collection := r.getCollection(ctx) // ✅ 自动切换数据库
    
    objectID, err := bson.ObjectIDFromHex(id)
    if err != nil {
        filter := bson.M{"_id": id, "is_deleted": 0}
        admin := &models.Admin{}
        err = collection.FindOne(ctx, filter).Decode(admin)
        // ...
    }
    
    // ❌ 无需：filter["tenant_id"] = tenantID
    filter := bson.M{"_id": objectID, "is_deleted": 0} // ✅ 简化查询
    admin := &models.Admin{}
    err = collection.FindOne(ctx, filter).Decode(admin)
    // ...
}

// Find 查询列表
func (r *adminRepository) Find(ctx context.Context, filter bson.M) ([]*models.Admin, error) {
    collection := r.getCollection(ctx) // ✅ 自动切换数据库
    
    // ❌ 无需：filter["tenant_id"] = tenantID
    // filter 已经自动作用于正确的租户数据库
    cursor, err := collection.Find(ctx, filter)
    // ...
}
```

**特殊：租户Repository** `internal/repository/tenant.go`

```go
// TenantRepository 租户仓库（只访问系统库）
type tenantRepository struct {
    dbManager *database.DatabaseManager
}

// getCollection 租户数据固定使用系统数据库
func (r *tenantRepository) getCollection() *mongo.Collection {
    db := r.dbManager.GetSystemDatabase() // ✅ 固定使用系统库
    return db.Collection("tenant")
}
```

---

### 阶段三：Service层改造（1-2天）

#### Step 6: Service层调整

**改造文件列表：**
- `app/system/services/admin.go`
- `app/system/services/tenant.go`
- `app/basic/services/*.go`

**主要改动：**
1. 删除所有 `tenant_id` 相关的过滤和验证逻辑
2. 确保所有方法传递正确的 Context

**示例改造：** `app/system/services/admin.go`

```go
// List 列表查询
func (s *AdminService) List(ctx context.Context, req dto.AdminListRequest) ([]models.Admin, int64, error) {
    // 构建过滤条件
    filter := bson.M{"is_deleted": 0}
    if req.Phone != "" {
        filter["phone"] = req.Phone
    }
    // ❌ 删除：if req.TenantID != "" { filter["tenant_id"] = req.TenantID }
    
    // ✅ Context会自动带上租户ID，Repository自动切换数据库
    total, err := s.repo.Count(ctx, filter)
    // ...
}

// Create 创建管理员
func (s *AdminService) Create(ctx context.Context, req dto.AdminCreateRequest) (*models.Admin, error) {
    // ❌ 删除：TenantID: req.TenantID
    admin := &models.Admin{
        Phone:    req.Phone,
        Password: hashedPassword,
        Nickname: req.Nickname,
        // ...
    }
    
    err := s.repo.Create(ctx, admin)
    // ...
}
```

**特殊：租户Service** `app/system/services/tenant.go`

```go
// Create 创建租户
func (s *TenantService) Create(ctx context.Context, req dto.TenantCreateRequest) (*models.Tenant, error) {
    // 1. 在系统库创建租户记录
    tenant := &models.Tenant{
        Code:    req.Code,
        Name:    req.Name,
        // ...
    }
    
    err := s.repo.Create(ctx, tenant) // 自动使用系统库
    if err != nil {
        return nil, err
    }
    
    // ✅ 2. 创建租户专属数据库
    dbManager := database.GetDatabaseManager()
    err = dbManager.CreateTenantDatabase(ctx, tenant.ID)
    if err != nil {
        // 回滚：删除租户记录
        s.repo.HardDelete(ctx, tenant.ID)
        return nil, fmt.Errorf("创建租户数据库失败: %v", err)
    }
    
    // ✅ 3. 在租户数据库中创建租户管理员
    tenantCtx := tenantCtx.WithTenantID(ctx, tenant.ID)
    adminService := NewAdminService()
    _, err = adminService.Create(tenantCtx, dto.AdminCreateRequest{
        Phone:    req.AdminPhone,
        Password: req.AdminPassword,
        Nickname: "租户管理员",
        Roles:    []string{"tenant_admin"},
        Status:   1,
    })
    if err != nil {
        // 回滚：删除数据库和租户记录
        dbManager.DeleteTenantDatabase(ctx, tenant.ID)
        s.repo.HardDelete(ctx, tenant.ID)
        return nil, fmt.Errorf("创建租户管理员失败: %v", err)
    }
    
    return tenant, nil
}

// Delete 删除租户
func (s *TenantService) Delete(ctx context.Context, id string) error {
    // 1. 软删除租户记录
    err := s.repo.Delete(ctx, id)
    if err != nil {
        return err
    }
    
    // ✅ 2. 删除租户数据库（可选，谨慎操作）
    // dbManager := database.GetDatabaseManager()
    // err = dbManager.DeleteTenantDatabase(ctx, id)
    // if err != nil {
    //     return fmt.Errorf("删除租户数据库失败: %v", err)
    // }
    
    return nil
}
```

---

### 阶段四：DTO和Transport层改造（1天）

#### Step 7: DTO改造

**改造文件：**
- `app/system/dto/admin.go`
- `app/auth/dto/auth.go`

**示例：** `app/system/dto/admin.go`

```go
// AdminListRequest 管理员列表请求
type AdminListRequest struct {
    Page     int64  `json:"page" form:"page"`
    PageSize int64  `json:"page_size" form:"page_size"`
    Phone    string `json:"phone" form:"phone"`
    Email    string `json:"email" form:"email"`
    Nickname string `json:"nickname" form:"nickname"`
    Status   *int   `json:"status" form:"status"`
    ID       string `json:"id" form:"id"`
    // ❌ 删除：TenantID string `json:"tenant_id" form:"tenant_id"`
}

// AdminCreateRequest 创建管理员请求
type AdminCreateRequest struct {
    Phone    string   `json:"phone" binding"required"`
    Password string   `json:"password" binding"required"`
    Nickname string   `json:"nickname" binding"required"`
    Email    string   `json:"email"`
    Roles    []string `json:"role"`
    Status   int      `json:"status"`
    // ❌ 删除：TenantID string `json:"tenant_id"`
}
```

#### Step 8: Transport层改造

**改造文件：**
- `app/system/transport/admin.go`
- `app/auth/transport/auth.go`

**主要改动：** 确保所有Service调用传递正确的Context

```go
// ListAdminHandler 管理员列表
func ListAdminHandler(svc services.IAdminService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(dto.AdminListRequest)
        
        // ✅ 传递Context（包含租户ID）
        admins, total, err := svc.List(ctx, req) // 之前可能是 svc.List(req)
        // ...
    }
}
```

---

### 阶段五：认证服务改造（1天）

#### Step 9: 认证服务改造

**文件：** `app/auth/services/auth.go`

```go
// Login 用户登录
func (s *AuthService) Login(ctx context.Context, phone, password string) (*dto.LoginResponse, error) {
    // 1. 先在系统库查找（系统超管）
    systemCtx := tenantCtx.WithTenantID(ctx, "") // 空租户ID = 系统库
    admin, err := s.repo.GetByPhone(systemCtx, phone)
    
    if admin == nil {
        // 2. 未找到，尝试在所有租户库中查找（性能优化：可建立手机号->租户映射表）
        tenants, _ := s.tenantRepo.FindAll(systemCtx)
        
        for _, tenant := range tenants {
            tenantCtx := tenantCtx.WithTenantID(ctx, tenant.ID)
            admin, err = s.repo.GetByPhone(tenantCtx, phone)
            if admin != nil {
                break
            }
        }
    }
    
    if admin == nil {
        return nil, errors.New("用户不存在")
    }
    
    // 3. 验证密码
    if !util.CheckPassword(password, admin.Password) {
        return nil, errors.New("密码错误")
    }
    
    // 4. 生成JWT Token
    tenantID := ""
    if !admin.IsSuperAdmin() {
        tenantID = getTenantIDFromContext(ctx)
    }
    
    token, err := s.jwtManager.GenerateToken(admin.ID, admin.Nickname, tenantID, admin.Roles)
    // ...
}
```

**性能优化：** 建立手机号到租户的映射表

```go
// PhoneToTenant 手机号租户映射表（系统库）
type PhoneToTenant struct {
    Phone    string `bson:"_id"` // 手机号作为主键
    TenantID string `bson:"tenant_id"`
}

// Login 优化版
func (s *AuthService) Login(ctx context.Context, phone, password string) (*dto.LoginResponse, error) {
    // 1. 先查映射表找到租户ID
    systemCtx := tenantCtx.WithTenantID(ctx, "")
    mapping := &PhoneToTenant{}
    err := s.mappingRepo.FindOne(systemCtx, bson.M{"_id": phone}).Decode(mapping)
    
    var admin *models.Admin
    if err == nil && mapping.TenantID != "" {
        // 2. 直接在对应租户库查找
        tenantCtx := tenantCtx.WithTenantID(ctx, mapping.TenantID)
        admin, _ = s.repo.GetByPhone(tenantCtx, phone)
    } else {
        // 3. 系统超管（系统库）
        admin, _ = s.repo.GetByPhone(systemCtx, phone)
    }
    
    // ...
}
```

---

### 阶段六：初始化和配置改造（1天）

#### Step 10: 服务启动初始化

**文件：** `cmd/system/main.go` 等所有服务的 main.go

```go
func main() {
    // 1. 加载配置
    cfg := config.Get()
    
    // 2. 初始化MongoDB客户端
    client, err := database.InitMongoDB(&cfg.MongoDB)
    if err != nil {
        log.Fatalf("初始化MongoDB失败: %v", err)
    }
    defer database.CloseMongoDB()
    
    // ✅ 3. 初始化数据库管理器
    dbManager := database.InitDatabaseManager(client)
    log.Println("✅ 数据库管理器初始化成功")
    
    // 4. 其他初始化...
    // ...
}
```

---

## 5. 代码改造清单

### 5.1 新建文件

| 文件路径 | 说明 |
|---------|------|
| `core/database/manager.go` | 多租户数据库管理器 |
| `core/context/tenant.go` | Context租户信息传递 |
| `docs/数据库级别租户隔离改造方案.md` | 本文档 |

### 5.2 修改文件

| 文件路径 | 改造内容 | 工作量 |
|---------|---------|--------|
| **模型层** | | |
| `internal/models/admin.go` | 删除 `TenantID` 字段 | 5分钟 |
| `internal/models/basic.go` | 删除 `TenantID` 字段和相关方法 | 5分钟 |
| `internal/models/role.go` | 删除 `TenantID` 字段 | 5分钟 |
| `internal/models/menu.go` | 删除 `TenantID` 字段 | 5分钟 |
| **Repository层** | | |
| `internal/repository/admin.go` | 改用DatabaseManager，删除tenant_id过滤 | 1小时 |
| `internal/repository/basic.go` | 同上 | 1小时 |
| `internal/repository/role.go` | 同上 | 1小时 |
| `internal/repository/menu.go` | 同上 | 1小时 |
| `internal/repository/tenant.go` | 固定使用系统库 | 30分钟 |
| **Service层** | | |
| `app/system/services/admin.go` | 删除tenant_id逻辑，传递Context | 1小时 |
| `app/system/services/tenant.go` | 添加创建/删除数据库逻辑 | 2小时 |
| `app/system/services/role.go` | 删除tenant_id逻辑 | 30分钟 |
| `app/system/services/menu.go` | 删除tenant_id逻辑 | 30分钟 |
| `app/basic/services/*.go` | 删除tenant_id逻辑 | 2小时 |
| `app/auth/services/auth.go` | 改造登录逻辑（跨库查询） | 2小时 |
| **Transport层** | | |
| `app/system/transport/admin.go` | 确保传递Context | 30分钟 |
| `app/system/transport/tenant.go` | 同上 | 30分钟 |
| `app/basic/transport/*.go` | 同上 | 1小时 |
| `app/auth/transport/auth.go` | 同上 | 30分钟 |
| **DTO层** | | |
| `app/system/dto/admin.go` | 删除 `TenantID` 字段 | 10分钟 |
| `app/auth/dto/auth.go` | 同上 | 10分钟 |
| **中间件** | | |
| `app/gateway/middleware/auth.go` | 添加Context传递逻辑 | 30分钟 |
| **启动文件** | | |
| `cmd/system/main.go` | 初始化DatabaseManager | 10分钟 |
| `cmd/basic/main.go` | 同上 | 10分钟 |
| `cmd/auth/main.go` | 同上 | 10分钟 |
| `cmd/gateway/main.go` | 同上 | 10分钟 |

**预计总工作量：** 2-3个工作日

---

## 6. 风险评估

### 6.1 技术风险

| 风险项 | 等级 | 影响 | 应对措施 |
|-------|------|------|---------|
| 登录性能下降（需跨库查询） | 中 | 登录响应时间增加 | 建立手机号->租户映射表 |
| 数据库连接数激增 | 中 | 内存占用增加 | 连接池复用，懒加载租户DB |
| 系统超管跨租户查询复杂 | 低 | 开发复杂度增加 | 提供专门的跨租户API |
| 租户数据迁移失败 | 高 | 数据丢失 | 完善的迁移脚本和回滚机制 |

### 6.2 业务风险

| 风险项 | 等级 | 影响 | 应对措施 |
|-------|------|------|---------|
| 改造期间服务不可用 | 中 | 业务中断 | 分阶段改造，灰度发布 |
| 数据不一致 | 高 | 数据错误 | 充分测试，数据校验脚本 |
| 前端兼容性问题 | 低 | 前端报错 | 后端向下兼容（忽略tenant_id字段） |

---

## 7. 数据迁移方案

### 7.1 迁移脚本

**文件：** `scripts/migrate_to_physical_isolation.js`

```javascript
// MongoDB Shell 迁移脚本
// 用法：mongo mule scripts/migrate_to_physical_isolation.js

const sourceDB = db.getSiblingDB("mule"); // 原数据库
const systemDB = db.getSiblingDB("tenant_system"); // 系统库

print("=== 开始数据迁移 ===");

// 1. 创建系统库，迁移租户数据
print("\n[1/4] 迁移租户数据到系统库...");
const tenants = sourceDB.tenant.find({ is_deleted: 0 }).toArray();
print(`找到 ${tenants.length} 个租户`);

systemDB.tenant.insertMany(tenants);
print("✅ 租户数据迁移完成");

// 2. 迁移系统超管到系统库
print("\n[2/4] 迁移系统超管到系统库...");
const superAdmins = sourceDB.admin.find({ 
    tenant_id: "", 
    role: { $in: ["super"] },
    is_deleted: 0 
}).toArray();

// 删除 tenant_id 字段
superAdmins.forEach(admin => {
    delete admin.tenant_id;
});

if (superAdmins.length > 0) {
    systemDB.admin.insertMany(superAdmins);
    print(`✅ 迁移 ${superAdmins.length} 个系统超管`);
}

// 3. 为每个租户创建独立数据库
print("\n[3/4] 为每个租户创建独立数据库...");
tenants.forEach(tenant => {
    const tenantID = tenant._id.toString();
    const tenantDBName = `tenant_${tenantID}`;
    const tenantDB = db.getSiblingDB(tenantDBName);
    
    print(`\n处理租户：${tenant.name} (${tenantID})`);
    
    // 迁移各个集合
    const collections = ["admin", "role", "menu", "basic", "color", "customer", "order_type", "procedure", "salesman", "size"];
    
    collections.forEach(collName => {
        const filter = { tenant_id: tenantID, is_deleted: 0 };
        const docs = sourceDB[collName].find(filter).toArray();
        
        if (docs.length > 0) {
            // 删除 tenant_id 字段
            docs.forEach(doc => {
                delete doc.tenant_id;
            });
            
            tenantDB[collName].insertMany(docs);
            print(`  ✅ ${collName}: ${docs.length} 条记录`);
        }
    });
    
    // 创建索引
    tenantDB.admin.createIndex({ phone: 1 }, { unique: true, sparse: true });
    tenantDB.admin.createIndex({ is_deleted: 1 });
    
    print(`✅ 租户 ${tenant.name} 数据库创建完成`);
});

// 4. 创建手机号映射表（性能优化）
print("\n[4/4] 创建手机号映射表...");
const allAdmins = sourceDB.admin.find({ 
    tenant_id: { $ne: "" }, 
    is_deleted: 0 
}).toArray();

const mappings = allAdmins.map(admin => ({
    _id: admin.phone,
    tenant_id: admin.tenant_id
}));

if (mappings.length > 0) {
    systemDB.phone_to_tenant.insertMany(mappings, { ordered: false });
    print(`✅ 创建 ${mappings.length} 条映射记录`);
}

print("\n=== 数据迁移完成 ===");
print("\n⚠️  请验证数据后再删除原数据库！");
print("验证命令：mongo mule scripts/verify_migration.js");
```

### 7.2 数据验证脚本

**文件：** `scripts/verify_migration.js`

```javascript
// 数据迁移验证脚本
const sourceDB = db.getSiblingDB("mule");
const systemDB = db.getSiblingDB("tenant_system");

print("=== 开始数据验证 ===\n");

let allSuccess = true;

// 1. 验证租户数量
const sourceTenantCount = sourceDB.tenant.countDocuments({ is_deleted: 0 });
const systemTenantCount = systemDB.tenant.countDocuments({ is_deleted: 0 });
print(`[1] 租户数量: 原库 ${sourceTenantCount} vs 系统库 ${systemTenantCount}`);
if (sourceTenantCount !== systemTenantCount) {
    print("❌ 租户数量不匹配！");
    allSuccess = false;
} else {
    print("✅ 租户数量匹配");
}

// 2. 验证每个租户的数据
const tenants = systemDB.tenant.find({ is_deleted: 0 }).toArray();
tenants.forEach(tenant => {
    const tenantID = tenant._id.toString();
    const tenantDBName = `tenant_${tenantID}`;
    const tenantDB = db.getSiblingDB(tenantDBName);
    
    print(`\n验证租户：${tenant.name}`);
    
    const collections = ["admin", "role", "menu", "basic"];
    collections.forEach(collName => {
        const sourceCount = sourceDB[collName].countDocuments({ 
            tenant_id: tenantID, 
            is_deleted: 0 
        });
        const tenantCount = tenantDB[collName].countDocuments({ is_deleted: 0 });
        
        print(`  ${collName}: 原库 ${sourceCount} vs 租户库 ${tenantCount}`);
        if (sourceCount !== tenantCount) {
            print(`  ❌ ${collName} 数量不匹配！`);
            allSuccess = false;
        }
    });
});

// 3. 验证系统超管
const sourceSuperCount = sourceDB.admin.countDocuments({ 
    tenant_id: "", 
    role: { $in: ["super"] },
    is_deleted: 0 
});
const systemSuperCount = systemDB.admin.countDocuments({ 
    role: { $in: ["super"] },
    is_deleted: 0 
});
print(`\n[3] 系统超管数量: 原库 ${sourceSuperCount} vs 系统库 ${systemSuperCount}`);
if (sourceSuperCount !== systemSuperCount) {
    print("❌ 系统超管数量不匹配！");
    allSuccess = false;
} else {
    print("✅ 系统超管数量匹配");
}

// 总结
print("\n=== 验证结果 ===");
if (allSuccess) {
    print("✅ 所有数据验证通过，可以删除原数据！");
    print("\n删除原数据库命令：");
    print("  use mule");
    print("  db.dropDatabase()");
} else {
    print("❌ 数据验证失败，请检查迁移脚本！");
}
```

### 7.3 回滚方案

保留原数据库 `mule` 不删除，直到新系统稳定运行至少1周。

如需回滚：
1. 停止所有服务
2. 恢复旧版代码
3. 重新部署
4. 删除新建的租户数据库

---

## 8. 测试计划

### 8.1 单元测试

**测试用例：**
- ✅ DatabaseManager 获取正确的租户数据库
- ✅ Context 正确传递租户ID
- ✅ Repository 自动切换数据库
- ✅ 租户创建自动创建数据库
- ✅ 系统超管访问系统库

### 8.2 集成测试

**测试场景：**
1. ✅ 创建租户 → 验证数据库创建 → 验证租户管理员创建
2. ✅ 租户A登录 → CRUD操作 → 验证数据在tenant_A库
3. ✅ 租户B登录 → CRUD操作 → 验证数据在tenant_B库
4. ✅ 租户A无法看到租户B的数据
5. ✅ 系统超管登录 → 查看所有租户
6. ✅ 删除租户 → 验证数据库删除（可选）

### 8.3 性能测试

**测试指标：**
- 登录响应时间（有映射表 vs 无映射表）
- 并发请求下的数据库连接数
- 内存占用（100个租户，1000个租户）
- 跨租户查询性能

### 8.4 压力测试

**测试场景：**
- 1000个租户同时在线
- 单租户高频访问
- 租户创建并发

---

## 9. 实施时间表

| 阶段 | 任务 | 工作量 | 负责人 | 预计完成时间 |
|-----|------|--------|--------|-------------|
| 阶段一 | 核心基础设施（DatabaseManager、Context） | 1-2天 | 后端 | Day 1-2 |
| 阶段二 | 模型和Repository层改造 | 2-3天 | 后端 | Day 3-5 |
| 阶段三 | Service层改造 | 1-2天 | 后端 | Day 6-7 |
| 阶段四 | DTO和Transport层改造 | 1天 | 后端 | Day 8 |
| 阶段五 | 认证服务改造 | 1天 | 后端 | Day 9 |
| 阶段六 | 初始化和配置改造 | 1天 | 后端 | Day 10 |
| 测试 | 单元测试、集成测试 | 2天 | 测试 | Day 11-12 |
| 迁移 | 数据迁移和验证 | 1天 | DBA | Day 13 |
| 上线 | 灰度发布和监控 | 1天 | 运维 | Day 14 |

**总计：** 约2周（10-14个工作日）

---

## 10. 注意事项

### 10.1 兼容性

- ✅ 后端忽略前端传来的 `tenant_id` 字段（向下兼容）
- ✅ JWT Token 保持 `tenant_id` 字段不变
- ✅ API响应不返回 `tenant_id`（前端需同步修改）

### 10.2 性能优化

- ✅ 使用手机号映射表加速登录
- ✅ 数据库连接池复用
- ✅ 懒加载租户数据库（首次访问时才创建连接）
- ✅ 考虑使用Redis缓存租户ID映射

### 10.3 运维建议

- ✅ 监控租户数据库数量
- ✅ 定期备份系统库（租户元数据）
- ✅ 定期备份各租户数据库
- ✅ 设置数据库连接数上限
- ✅ 监控内存和磁盘占用

### 10.4 安全建议

- ✅ 租户数据库命名使用UUID（不可预测）
- ✅ 每个租户数据库独立用户权限（可选）
- ✅ 定期审计跨租户访问日志
- ✅ 系统超管操作记录审计

---

## 11. 总结

### 11.1 改造收益

| 维度 | 改造前 | 改造后 | 提升 |
|-----|--------|--------|------|
| 安全性 | 逻辑隔离（易出错） | 物理隔离（完全隔离） | ⭐⭐⭐⭐⭐ |
| 代码复杂度 | 每处需过滤tenant_id | 自动切换数据库 | ⭐⭐⭐⭐ |
| 扩展性 | 单库瓶颈 | 分散压力 | ⭐⭐⭐⭐ |
| 运维便利性 | 租户备份困难 | 独立备份/迁移 | ⭐⭐⭐⭐⭐ |
| 性能 | 单库压力大 | 分散负载 | ⭐⭐⭐ |

### 11.2 关键点

- ✅ **数据库管理器**是核心，负责租户数据库的创建、切换和管理
- ✅ **Context传递**是关键，确保租户信息正确传递到Repository层
- ✅ **系统库**独立存储租户元数据和系统超管
- ✅ **映射表**优化登录性能
- ✅ **分阶段改造**降低风险

### 11.3 后续优化

- 考虑使用PostgreSQL替代MongoDB（支持Schema级别隔离）
- 考虑使用分布式数据库（如TiDB）支持更大规模租户
- 考虑使用Service Mesh统一管理租户路由
- 考虑使用读写分离优化性能

---

**文档版本：** v1.0  
**创建日期：** 2025-10-02  
**作者：** Mule-Cloud 团队  
**状态：** 待评审

