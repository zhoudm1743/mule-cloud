# 修复：超管切换租户后数据库未正常获取

## 问题描述

超管通过 `X-Tenant-Context` header 切换租户后，虽然租户上下文切换成功，但查询时仍然使用系统数据库 `tenant_system`，而不是目标租户数据库（如 `mule_ace`）。

### 问题日志

```
2025/10/08 19:53:05 [租户上下文切换] ✅ 系统管理员切换到租户: ace
2025/10/08 19:53:05 [租户上下文切换] ✅ 切换后验证 tenantCode: 'ace'
2025/10/08 19:53:05 [MongoDB] 执行命令: find, ... "$db": "tenant_system"}  // ❌ 错误！应该是 mule_ace
```

## 问题原因

问题出现在三个层面：

### 1. Service 层丢失 Context（主要问题）

在 `app/perms/services/admin.go` 中，所有服务方法都创建了新的 `context.Background()`，丢失了从上层传递下来的租户上下文：

```go
// ❌ 问题代码
func (s *AdminService) List(req dto.AdminListRequest) ([]models.Admin, int64, error) {
    ctx := context.Background()  // 丢失了租户上下文！
    // ...
}
```

### 2. Repository 使用了错误的方法

Service 层直接调用了 `s.repo.GetCollection()`，这个方法返回的是系统数据库的集合：

```go
// ❌ 问题代码
func (r *adminRepository) GetCollection() *mongo.Collection {
    // 返回系统库的collection作为默认值（向下兼容）
    return r.dbManager.GetSystemDatabase().Collection("admin")
}
```

### 3. DatabaseManager 未处理 "system" tenantCode

`GetDatabase()` 方法只检查空字符串，没有检查 "system"：

```go
// ❌ 问题代码
if tenantCode == "" {
    return m.systemDB
}
```

## 修复方案

### 1. 修改 Service 接口和实现

修改 `IAdminService` 接口，为所有方法添加 `ctx context.Context` 参数：

```go
// ✅ 修复后
type IAdminService interface {
    Get(ctx context.Context, id string) (*models.Admin, error)
    GetAll(ctx context.Context, req dto.AdminListRequest) ([]models.Admin, error)
    List(ctx context.Context, req dto.AdminListRequest) ([]models.Admin, int64, error)
    Create(ctx context.Context, req dto.AdminCreateRequest) (*models.Admin, error)
    Update(ctx context.Context, req dto.AdminUpdateRequest) (*models.Admin, error)
    Delete(ctx context.Context, id string) error
}
```

修改所有方法实现，使用传入的 `ctx` 而不是 `context.Background()`：

```go
// ✅ 修复后
func (s *AdminService) List(ctx context.Context, req dto.AdminListRequest) ([]models.Admin, int64, error) {
    // 使用传入的 ctx，保留租户上下文
    // ...
}
```

### 2. 添加 Repository 的 Context 方法

在 `AdminRepository` 接口中添加新方法：

```go
// ✅ 新增方法
GetCollectionWithContext(ctx context.Context) *mongo.Collection
```

实现该方法：

```go
// ✅ 实现
func (r *adminRepository) GetCollectionWithContext(ctx context.Context) *mongo.Collection {
    return r.getCollection(ctx)  // 使用内部方法，根据 ctx 中的 tenantCode 获取正确的数据库
}
```

Service 层改用新方法：

```go
// ✅ 修复后
collection := s.repo.GetCollectionWithContext(ctx)
```

### 3. 修复 DatabaseManager

修改 `GetDatabase()` 方法，同时处理空字符串和 "system"：

```go
// ✅ 修复后
func (m *DatabaseManager) GetDatabase(tenantCode string) *mongo.Database {
    // 系统超管使用系统库
    if tenantCode == "" || tenantCode == "system" {
        return m.systemDB
    }
    // ...
}
```

### 4. 更新 Endpoint 层

修改所有 endpoint，传递 context 给 service：

```go
// ✅ 修复后
func ListAdminsEndpoint(svc services.IAdminService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(dto.AdminListRequest)
        admins, total, err := svc.List(ctx, req)  // 传递 ctx
        // ...
    }
}
```

### 5. 更新调用方

修改 `tenant.go` 中调用 admin service 的地方：

```go
// ✅ 修复后
_, err = adminService.Create(tenantCtx, dto.AdminCreateRequest{
    // ...
})
```

## 修改的文件

1. `app/perms/services/admin.go` - 修改接口和所有方法实现
2. `app/perms/endpoint/admin.go` - 修改所有 endpoint 传递 context
3. `internal/repository/admin.go` - 添加 `GetCollectionWithContext` 方法
4. `core/database/manager.go` - 修复 `GetDatabase` 方法
5. `app/perms/services/tenant.go` - 更新 admin service 调用

## 验证

修复后，超管切换租户时应该正确查询租户数据库：

```
[租户上下文切换] ✅ 系统管理员切换到租户: ace
[租户上下文切换] ✅ 切换后验证 tenantCode: 'ace'
[MongoDB] 执行命令: find, ... "$db": "mule_ace"}  // ✅ 正确！
```

## 经验教训

1. **Context 传递的重要性**：在微服务架构中，Context 是传递请求级别信息的关键，绝对不能在中间层丢失
2. **分层架构的一致性**：如果底层（repository）支持 context，那么上层（service、endpoint）也必须支持
3. **向下兼容的风险**：`GetCollection()` 这种"向下兼容"的方法容易导致错误使用
4. **边界条件处理**：要考虑特殊值（如 "system"）的处理

## 建议

1. 考虑为所有其他服务（role、menu、dept 等）做同样的修复
2. 考虑废弃 `GetCollection()` 方法，强制使用 `GetCollectionWithContext(ctx)`
3. 添加单元测试验证租户切换功能

