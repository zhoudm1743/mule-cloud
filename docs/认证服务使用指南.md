# 认证服务使用指南

## 概述

认证服务提供完整的用户认证、授权和个人信息管理功能，基于 JWT 实现无状态认证。

## 快速开始

### 1. 初始化数据库

使用提供的脚本初始化测试用户：

```bash
# 方式1：使用 mongosh (推荐)
mongosh mongodb://root:bgg8384495@localhost:27015/mule?authSource=admin < scripts/init_auth_users.js

# 方式2：直接在 mongosh 中运行
mongosh mongodb://root:bgg8384495@localhost:27015/mule?authSource=admin
> load('scripts/init_auth_users.js')
```

该脚本会创建 3 个测试用户：

| 手机号 | 密码 | 角色 | 昵称 |
|--------|------|------|------|
| 13800138000 | 123456 | user | 测试用户 |
| 13900139000 | 123456 | admin, user | 管理员 |
| 13700137000 | 123456 | editor, user | 编辑员 |

### 2. 启动认证服务

```bash
# 启动服务
go run cmd/auth/main.go

# 或使用自定义配置
go run cmd/auth/main.go -config=config/auth.yaml
```

服务默认运行在 `http://localhost:8002`

### 3. 运行测试脚本

```bash
# 自动测试所有 API
bash scripts/test_auth_api.sh
```

## API 使用示例

### 1. 用户注册

```bash
curl -X POST http://localhost:8002/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "phone": "13812345678",
    "password": "123456",
    "nickname": "新用户",
    "email": "newuser@example.com"
  }'
```

### 2. 用户登录

```bash
curl -X POST http://localhost:8002/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "phone": "13800138000",
    "password": "123456"
  }'
```

响应示例：
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "user_id": "13800138000",
    "phone": "13800138000",
    "nickname": "测试用户",
    "avatar": "https://avatar.example.com/test.jpg",
    "role": ["user"],
    "expires_at": 1696147200
  }
}
```

### 3. 获取个人信息

```bash
# 先获取 token
TOKEN=$(curl -s -X POST http://localhost:8002/auth/login \
  -H "Content-Type: application/json" \
  -d '{"phone":"13800138000","password":"123456"}' | jq -r '.data.token')

# 使用 token 获取个人信息
curl -X GET http://localhost:8002/auth/profile \
  -H "Authorization: Bearer $TOKEN"
```

### 4. 更新个人信息

```bash
curl -X PUT http://localhost:8002/auth/profile \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "nickname": "新昵称",
    "avatar": "https://new-avatar.com/image.jpg",
    "email": "newemail@example.com"
  }'
```

### 5. 修改密码

```bash
curl -X POST http://localhost:8002/auth/password \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "old_password": "123456",
    "new_password": "654321"
  }'
```

### 6. 刷新 Token

```bash
curl -X POST http://localhost:8002/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{
    "token": "'$TOKEN'"
  }'
```

## 与其他服务集成

### 在其他服务中使用认证

其他服务可以引用 auth 服务的 middleware 来验证 JWT token：

```go
import (
    jwtPkg "mule-cloud/core/jwt"
    "mule-cloud/app/gateway/middleware"
)

func main() {
    // 初始化 JWT 管理器
    jwtManager := jwtPkg.NewJWTManager(
        []byte(cfg.JWT.SecretKey),
        time.Duration(cfg.JWT.ExpireTime)*time.Hour,
    )
    
    // 在路由中使用认证中间件
    r := gin.New()
    
    // 需要认证的路由
    protected := r.Group("/api")
    protected.Use(middleware.JWTAuth(jwtManager))
    {
        protected.GET("/data", handler)
    }
    
    // 需要特定角色的路由
    admin := r.Group("/admin")
    admin.Use(middleware.JWTAuth(jwtManager))
    admin.Use(middleware.RequireRole("admin"))
    {
        admin.POST("/users", createUserHandler)
    }
}
```

### 通过网关访问

在网关配置中添加认证服务路由：

```yaml
# config/gateway.yaml
gateway:
  routes:
    /auth:
      service_name: "authservice"
      require_auth: false  # 公开接口不需要认证
      require_role: []
```

然后通过网关访问：

```bash
# 通过网关登录
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{"phone":"13800138000","password":"123456"}'
```

## 角色权限管理

### 内置角色

- `user`: 普通用户，基础权限
- `admin`: 管理员，所有权限
- `editor`: 编辑员，内容管理权限

### 检查用户角色

在业务代码中检查角色：

```go
// 从 Context 获取 claims
claimsValue, _ := c.Get("claims")
claims := claimsValue.(*jwt.Claims)

// 检查单个角色
if claims.HasRole("admin") {
    // 管理员操作
}

// 检查多个角色（有任意一个即可）
if claims.HasAnyRole("admin", "editor") {
    // 管理员或编辑员操作
}
```

### 自定义角色

在用户注册或更新时可以设置自定义角色：

```javascript
// MongoDB 中添加自定义角色
db.admins.updateOne(
  { phone: "13800138000" },
  { $set: { role: ["user", "vip", "premium"] } }
)
```

## 安全配置

### 1. 修改 JWT Secret Key

编辑 `config/auth.yaml`：

```yaml
jwt:
  secret_key: "your-super-secret-key-at-least-32-characters-long"
  expire_time: 24  # Token 过期时间（小时）
```

**生产环境建议：**
- 使用至少 32 字符的强密钥
- 使用环境变量或配置中心管理
- 定期轮换密钥

### 2. 升级密码加密算法

当前使用 MD5（仅供开发测试），生产环境应使用 bcrypt：

```go
// 安装 bcrypt
go get golang.org/x/crypto/bcrypt

// 修改 app/auth/services/auth.go
import "golang.org/x/crypto/bcrypt"

func hashPassword(password string) string {
    hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return ""
    }
    return string(hash)
}

func checkPassword(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}
```

### 3. 添加限流保护

使用 Redis 实现登录限流：

```go
// 检查登录次数
key := fmt.Sprintf("login:attempts:%s", req.Phone)
attempts, _ := redis.Get(key).Int()

if attempts >= 5 {
    return nil, errors.New("登录失败次数过多，请稍后再试")
}

// 登录失败时增加计数
redis.Incr(key)
redis.Expire(key, 15*time.Minute)
```

### 4. Token 黑名单

实现用户登出功能：

```go
// 登出时将 token 加入黑名单
func (s *AuthService) Logout(token string) error {
    claims, err := s.jwtManager.ValidateToken(token)
    if err != nil {
        return err
    }
    
    // 计算 token 剩余有效时间
    expireTime := time.Until(claims.ExpiresAt.Time)
    
    // 存入 Redis 黑名单
    key := fmt.Sprintf("token:blacklist:%s", token)
    return redis.Set(key, "1", expireTime).Err()
}

// 在中间件中检查黑名单
func JWTAuthWithBlacklist(jwtManager *jwt.JWTManager) gin.HandlerFunc {
    return func(c *gin.Context) {
        token := getTokenFromHeader(c)
        
        // 检查是否在黑名单中
        key := fmt.Sprintf("token:blacklist:%s", token)
        exists, _ := redis.Exists(key).Result()
        if exists > 0 {
            response.ErrorWithCode(c, 401, "token已失效")
            c.Abort()
            return
        }
        
        // 验证 token
        // ...
    }
}
```

## 常见问题

### Q1: Token 过期后怎么办？

使用刷新 Token 接口获取新的 Token：

```bash
curl -X POST http://localhost:8002/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{"token":"<expired_token>"}'
```

### Q2: 如何实现记住登录？

前端存储 Token 到 localStorage 或 cookie，每次请求时携带。

### Q3: 如何实现多端登录互踢？

使用 Redis 存储用户最新的 Token，登录时更新，验证时对比。

### Q4: 密码忘记了怎么办？

需要实现短信验证码或邮箱验证重置密码功能。

### Q5: 如何获取当前登录用户信息？

在处理器中从 Context 获取：

```go
func MyHandler(c *gin.Context) {
    userID, _ := c.Get("user_id")
    username, _ := c.Get("username")
    roles, _ := c.Get("roles")
    
    // 使用用户信息
    log.Printf("用户 %s(%s) 访问，角色: %v", username, userID, roles)
}
```

## 性能优化

### 1. 数据库索引

```javascript
// 创建必要的索引
db.admins.createIndex({ "phone": 1 }, { unique: true })
db.admins.createIndex({ "email": 1 })
db.admins.createIndex({ "status": 1 })
```

### 2. 连接池配置

在 `config/auth.yaml` 中调整 MongoDB 连接池：

```yaml
mongodb:
  max_pool_size: 100
  min_pool_size: 10
```

### 3. 使用 Redis 缓存用户信息

```go
// 登录后缓存用户信息
func (s *AuthService) Login(req dto.LoginRequest) (*dto.LoginResponse, error) {
    // ... 登录逻辑
    
    // 缓存用户信息（5分钟）
    key := fmt.Sprintf("user:info:%s", admin.Phone)
    userData, _ := json.Marshal(admin)
    redis.Set(key, userData, 5*time.Minute)
    
    return response, nil
}
```

## 监控和日志

### 查看服务日志

```bash
# 实时查看日志
tail -f logs/auth.log

# 搜索错误日志
grep "ERROR" logs/auth.log

# 统计登录次数
grep "登录成功" logs/auth.log | wc -l
```

### 关键指标监控

建议监控以下指标：

- 登录成功率
- Token 验证失败率
- 平均响应时间
- 并发连接数
- 数据库连接池使用率

## 下一步

- [ ] 实现短信验证码注册
- [ ] 实现邮箱验证
- [ ] 实现第三方登录（微信、QQ 等）
- [ ] 实现 OAuth2.0
- [ ] 添加图形验证码
- [ ] 实现设备管理
- [ ] 添加登录日志审计

