# 权限体系整合方案

## 当前架构

### 两种权限控制方式

#### 1. 基于角色的菜单分配（后端控制）
```
Tenant.menus: ['dashboard', 'admin', 'role']  // 租户拥有的菜单
Role.menus: ['admin', 'role']                  // 角色拥有的菜单
Admin.roles: ['role1', 'role2']                // 用户的角色
```

**流程：**
1. 用户登录 → 获取用户的角色列表
2. 根据角色查询所有角色拥有的菜单（取并集）
3. 与租户的菜单取交集（租户限制）
4. 返回最终的菜单列表给前端

#### 2. 菜单级角色限制（前端过滤）
```go
Menu.Roles: ['admin', 'super']  // 这个菜单只允许 admin 和 super 角色访问
```

**前端逻辑：**
```typescript
// helper.ts
resultRouter = resultRouter.filter(i => hasPermission(i.meta.roles))

// usePermission.ts
hasPermission(permission) {
  const { role } = authStore.userInfo
  // 如果菜单设置了 roles，检查用户角色是否在允许列表中
  return permission.some(i => role.includes(i))
}
```

## 整合方案

### 🎯 推荐方案：两层权限控制

#### 第一层：租户/角色菜单分配（粗粒度）
- **目的**：控制大范围的功能模块访问
- **位置**：后端 Tenant/Role 的 menus 字段
- **控制**：用户能看到哪些菜单模块

#### 第二层：菜单角色限制（细粒度）
- **目的**：在菜单级别进一步细化权限
- **位置**：Menu 的 roles 字段
- **控制**：即使角色有这个菜单权限，也要检查用户角色是否匹配

### 实现逻辑

```
用户访问菜单的条件（AND 关系）：
1. ✅ 租户拥有该菜单（Tenant.menus 包含）
2. ✅ 用户角色拥有该菜单（Role.menus 包含）
3. ✅ 用户角色在菜单允许的角色列表中（Menu.roles 为空或包含用户角色）
```

## 使用场景

### 场景1：基础权限控制（当前实现）
```yaml
租户: 超管
  menus: [dashboard, system, admin, role, tenant, menu]
  
角色: 系统管理员
  menus: [dashboard, system, admin, role]
  
角色: 普通管理员
  menus: [dashboard, admin]
```

### 场景2：增加细粒度控制（使用 Menu.Roles）
```yaml
菜单: admin（管理员管理）
  roles: [super, admin]  # 只有 super 和 admin 角色能访问
  
菜单: tenant（租户管理）
  roles: [super]  # 只有 super 角色能访问
  
菜单: dashboard（仪表盘）
  roles: []  # 空表示所有角色都能访问
```

**效果：**
- 即使"系统管理员"角色被分配了 `admin` 菜单
- 但如果用户的实际角色是 `viewer`（只读角色）
- 前端会过滤掉这个菜单（因为 `viewer` 不在 Menu.roles 中）

## 实施步骤

### 1. 后端改造

#### a. Auth Service 返回用户角色信息
```go
// auth/services/auth.go - Login 方法
type LoginResponse struct {
    Token     string   `json:"token"`
    UserID    string   `json:"user_id"`
    Roles     []string `json:"role"`  // 返回角色的 code，如 ['super', 'admin']
    // ...
}
```

#### b. 获取角色的 code 而不是 ID
```go
// 从 Admin.roles (角色ID数组) 查询对应的 Role.code
roleNames := []string{}
for _, roleID := range admin.Roles {
    role, _ := roleRepo.GetByID(ctx, roleID)
    if role != nil {
        roleNames = append(roleNames, role.Code)  // 使用 code，如 "admin"
    }
}
```

### 2. 前端改造（已实现）

前端已经有完整的 `hasPermission` 逻辑：

```typescript
// helper.ts - 创建路由时过滤
resultRouter = resultRouter.filter(i => hasPermission(i.meta.roles))

// usePermission.ts - 权限检查
function hasPermission(permission?: Entity.RoleType | Entity.RoleType[]) {
  if (!permission) return true  // Menu.roles 为空，所有人可访问
  
  const { role } = authStore.userInfo  // 用户的角色列表
  return permission.some(i => role.includes(i))  // 检查是否有交集
}
```

### 3. 数据库设计

#### Menu 表
```go
type Menu struct {
    Name  string   `json:"name"`   // 唯一标识
    Roles []string `json:"roles"`  // 允许的角色 code 列表，如 ['admin', 'super']
    // ...
}
```

#### Role 表
```go
type Role struct {
    Code  string   `json:"code"`   // 角色代码（唯一），如 'admin', 'super'
    Name  string   `json:"name"`   // 角色名称（显示用），如 '系统管理员'
    Menus []string `json:"menus"`  // 角色拥有的菜单 name 列表
    // ...
}
```

#### Admin 表
```go
type Admin struct {
    Roles []string `json:"roles"`  // 用户的角色 ID 列表
    // ...
}
```

## 配置示例

### 1. 创建角色
```json
{
  "code": "admin",
  "name": "系统管理员",
  "menus": ["dashboard", "system", "admin", "role", "tenant"]
}

{
  "code": "viewer",
  "name": "只读用户",
  "menus": ["dashboard", "system", "admin", "role"]
}
```

### 2. 配置菜单
```json
{
  "name": "admin",
  "title": "管理员管理",
  "roles": ["admin", "super"]  // 只有 admin 和 super 角色能访问
}

{
  "name": "tenant",
  "title": "租户管理",
  "roles": ["super"]  // 只有 super 角色能访问
}

{
  "name": "dashboard",
  "title": "仪表盘",
  "roles": []  // 所有角色都能访问
}
```

### 3. 分配用户
```json
{
  "phone": "13800138000",
  "roles": ["role_id_of_admin"]  // 用户属于 admin 角色
}
```

### 4. 权限检查
```
用户登录后：
- role: ['admin']
- 通过角色获得的菜单: ['dashboard', 'system', 'admin', 'role', 'tenant']

前端过滤：
- dashboard: roles=[] → ✅ 通过（空表示所有角色）
- admin: roles=['admin', 'super'] → ✅ 通过（用户是 admin）
- tenant: roles=['super'] → ❌ 拒绝（用户不是 super）

最终可访问：['dashboard', 'system', 'admin', 'role']
```

## 优势

### 1. 灵活性
- 可以只使用第一层（角色分配），不设置 Menu.roles
- 可以两层结合，实现更细粒度的控制

### 2. 安全性
- 后端控制大范围访问（Tenant/Role.menus）
- 前端过滤敏感功能（Menu.roles）
- 双重保障

### 3. 可维护性
- 角色管理员可以分配菜单（第一层）
- 系统管理员可以设置菜单的角色限制（第二层）
- 职责分离

## 注意事项

### 1. 角色标识统一
```
Menu.roles = ['admin', 'super']  ← 使用 Role.code
User.role = ['admin']            ← 登录时从 Role.code 获取
```

### 2. 空值处理
```typescript
Menu.roles = []      // 空数组 = 所有角色可访问
Menu.roles = null    // null = 所有角色可访问
Menu.roles = ['admin']  // 只有 admin 角色可访问
```

### 3. super 角色
```typescript
// usePermission.ts
let has = role.includes('super')  // super 角色绕过所有检查
```

### 4. 后端也要检查
前端过滤只是 UX 优化，后端 API 也要验证：
```go
// Gateway 或各服务的中间件
if !user.HasRole(menu.Roles) {
    return errors.New("权限不足")
}
```

## 下一步

### 立即可做
1. ✅ Menu 已有 roles 字段
2. ✅ 前端已有 hasPermission 逻辑
3. ⏭️ 后端 Login 返回角色 code（而不是 ID）
4. ⏭️ 在菜单管理界面支持编辑 roles 字段

### 长期优化
1. Casbin 集成 - 使用更强大的权限策略
2. 权限缓存 - 减少数据库查询
3. 权限审计 - 记录权限变更历史

