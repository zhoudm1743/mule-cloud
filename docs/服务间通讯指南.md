# 服务间通讯指南

## 📖 概述

Mule-Cloud项目使用 **HTTP + Consul服务发现** 进行服务间通讯。

## 🏗️ 通讯架构

```
┌─────────────┐
│  前端/客户端 │
└──────┬──────┘
       │ ① HTTP + JWT
       ↓
┌─────────────────────┐
│    API网关 (:8080)  │
└──────┬──────────────┘
       │ ② HTTP (服务发现)
       ├──────────────┐
       ↓              ↓
┌────────────┐  ┌────────────┐
│ Test服务   │  │ Basic服务  │
│  (:8000)   │←③│  (:8001)   │
└────────────┘  └────────────┘
  HTTP调用（服务间）
       ↑
       └── Consul服务发现
```

## 🔄 三种通讯方式

### 1. 客户端 → 网关 → 服务

**场景**: 前端或外部客户端访问微服务

```bash
# 客户端请求
curl -H "Authorization: Bearer {token}" \
  http://localhost:8080/test/admin/1

# 流程:
前端 → 网关(:8080) → Consul查找"testservice" → 转发到test服务(:8000)
```

**特点**:
- ✅ 统一入口
- ✅ 统一认证
- ✅ 限流保护

### 2. 服务A → 服务B (HTTP调用)

**场景**: 微服务之间需要互相调用

**示例**: Test服务调用Basic服务获取颜色信息

```go
// test/services/user.go

// 1. 创建HTTP客户端
httpClient, _ := httpclient.NewServiceClient("127.0.0.1:8500")

// 2. 调用其他服务
var colorResp ColorResponse
err := httpClient.CallService(
    ctx,
    "GET",
    "basicservice",        // 服务名（Consul中注册的名字）
    "/basic/color/1",      // 路径
    nil,                   // 请求体
    &colorResp,            // 响应数据
    nil,                   // 额外headers
)

// 3. 使用响应数据
if colorResp.Code == 0 {
    color := colorResp.Data.Color
    // 业务逻辑...
}
```

**流程**:
```
Test服务 → Consul查找"basicservice" 
         → 获取地址(192.168.31.78:8001) 
         → HTTP GET /basic/color/1 
         → Basic服务处理并返回
```

### 3. 网关 → 服务 (反向代理)

**场景**: 网关转发请求到后端服务

```go
// gateway/main.go

// 网关自动从Consul获取服务地址并转发
targetURL, _ := gw.getServiceAddress("testservice")
proxy := httputil.NewSingleHostReverseProxy(target)
proxy.ServeHTTP(c.Writer, c.Request)
```

## 🛠️ 实现方式

### 方式1: 使用封装的 ServiceClient（推荐）

**优点**: 
- ✅ 自动服务发现
- ✅ 统一错误处理
- ✅ 简单易用

```go
// 1. 创建客户端
import "mule-cloud/core/httpclient"

client, err := httpclient.NewServiceClient("127.0.0.1:8500")

// 2. GET请求
respBody, err := client.Get(ctx, "basicservice", "/basic/color/1", nil)

// 3. POST请求
reqData := map[string]interface{}{
    "name": "测试",
    "email": "test@example.com",
}
respBody, err := client.Post(ctx, "testservice", "/admin", reqData, nil)

// 4. 自动解析响应
type Response struct {
    Code int         `json:"code"`
    Data interface{} `json:"data"`
}
var resp Response
err := client.CallService(ctx, "GET", "basicservice", "/basic/color/1", nil, &resp, nil)
```

### 方式2: 手动实现

```go
import (
    "github.com/hashicorp/consul/api"
    "net/http"
)

// 1. 连接Consul
config := api.DefaultConfig()
config.Address = "127.0.0.1:8500"
consulClient, _ := api.NewClient(config)

// 2. 查询服务
services, _, _ := consulClient.Health().Service("basicservice", "", true, nil)
service := services[0].Service
baseURL := fmt.Sprintf("http://%s:%d", service.Address, service.Port)

// 3. 发送HTTP请求
resp, _ := http.Get(baseURL + "/basic/color/1")
defer resp.Body.Close()

// 4. 处理响应
body, _ := io.ReadAll(resp.Body)
```

## 📝 完整示例

### 场景: Test服务获取用户喜欢的颜色

#### 1. Service层（业务逻辑）

```go
// test/services/user.go
package services

import (
    "context"
    "mule-cloud/core/httpclient"
)

type UserService struct {
    httpClient *httpclient.ServiceClient
}

func NewUserService(consulAddr string) IUserService {
    client, _ := httpclient.NewServiceClient(consulAddr)
    return &UserService{httpClient: client}
}

func (s *UserService) GetUserWithColor(userID string) (*UserWithColorInfo, error) {
    // 1. 本地数据
    user := &UserWithColorInfo{
        UserID:   userID,
        Username: "user_" + userID,
    }

    // 2. 调用basic服务
    ctx := context.Background()
    var colorResp ColorResponse
    
    err := s.httpClient.CallService(
        ctx,
        "GET",
        "basicservice",      // 目标服务
        "/basic/color/1",    // 接口路径
        nil,
        &colorResp,
        nil,
    )

    if err != nil {
        return nil, err
    }

    // 3. 组合数据
    user.FavoriteColor = colorResp.Data.Color
    return user, nil
}
```

#### 2. Endpoint层

```go
// test/endpoint/user.go
func GetUserWithColorEndpoint(svc services.IUserService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(UserRequest)
        user, err := svc.GetUserWithColor(req.ID)
        if err != nil {
            return nil, err
        }
        return UserResponse{User: user}, nil
    }
}
```

#### 3. Transport层

```go
// test/transport/user.go
func GetUserWithColorHandler(svc services.IUserService) gin.HandlerFunc {
    return func(c *gin.Context) {
        var req endpoint.UserRequest
        if err := c.ShouldBindUri(&req); err != nil {
            response.Error(c, "参数错误")
            return
        }

        ep := endpoint.GetUserWithColorEndpoint(svc)
        resp, err := ep(c.Request.Context(), req)
        if err != nil {
            response.Error(c, err.Error())
            return
        }

        response.Success(c, resp)
    }
}
```

#### 4. 注册路由

```go
// test/cmd/main.go
func main() {
    // 创建服务（传入Consul地址）
    userSvc := services.NewUserService("127.0.0.1:8500")

    r := gin.Default()
    
    user := r.Group("/user")
    {
        user.GET("/:id", transport.GetUserWithColorHandler(userSvc))
    }

    r.Run(":8000")
}
```

#### 5. 测试

```bash
# 通过网关访问
curl http://localhost:8080/test/user/123

# 响应
{
  "code": 0,
  "msg": "success",
  "data": {
    "user": {
      "user_id": "123",
      "username": "user_123",
      "favorite_color": {
        "id": "1",
        "name": "红色",
        "hex_code": "#FF0000"
      }
    }
  }
}
```

## 🔒 认证传递

### 场景: 服务间调用需要传递用户信息

```go
// 从网关获取用户信息
userID := c.GetHeader("X-User-ID")
username := c.GetHeader("X-Username")

// 调用其他服务时传递
headers := map[string]string{
    "X-User-ID": userID,
    "X-Username": username,
}

err := httpClient.CallService(
    ctx,
    "POST",
    "otherservice",
    "/some/path",
    reqData,
    &respData,
    headers,  // 传递用户信息
)
```

## ⚡ 性能优化

### 1. 连接复用

```go
// 在服务初始化时创建一次
type MyService struct {
    httpClient *httpclient.ServiceClient  // 复用连接
}

func NewMyService(consulAddr string) *MyService {
    client, _ := httpclient.NewServiceClient(consulAddr)
    return &MyService{httpClient: client}
}
```

### 2. 超时控制

```go
// 设置超时
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

err := httpClient.CallService(ctx, "GET", "service", "/path", nil, &resp, nil)
```

### 3. 并发调用

```go
// 同时调用多个服务
var wg sync.WaitGroup
var color *ColorInfo
var size *SizeInfo

// 调用颜色服务
wg.Add(1)
go func() {
    defer wg.Done()
    httpClient.CallService(ctx, "GET", "basicservice", "/basic/color/1", nil, &color, nil)
}()

// 调用尺寸服务
wg.Add(1)
go func() {
    defer wg.Done()
    httpClient.CallService(ctx, "GET", "basicservice", "/basic/size/1", nil, &size, nil)
}()

wg.Wait()
```

## 🐛 错误处理

### 1. 服务不可用

```go
err := httpClient.CallService(...)
if err != nil {
    if strings.Contains(err.Error(), "未找到服务") {
        // 服务未注册到Consul
        return fmt.Errorf("服务暂时不可用")
    }
    return err
}
```

### 2. 超时处理

```go
ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
defer cancel()

err := httpClient.CallService(ctx, ...)
if err != nil {
    if ctx.Err() == context.DeadlineExceeded {
        // 超时
        return fmt.Errorf("调用服务超时")
    }
}
```

### 3. 重试机制

```go
func callWithRetry(fn func() error, maxRetries int) error {
    var err error
    for i := 0; i < maxRetries; i++ {
        err = fn()
        if err == nil {
            return nil
        }
        time.Sleep(time.Duration(i+1) * 100 * time.Millisecond)
    }
    return fmt.Errorf("重试%d次后失败: %v", maxRetries, err)
}

// 使用
err := callWithRetry(func() error {
    return httpClient.CallService(...)
}, 3)
```

## 📊 对比：HTTP vs gRPC

| 特性 | HTTP/REST | gRPC |
|------|-----------|------|
| 性能 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 易用性 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 调试 | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 浏览器支持 | ✅ | ❌ |
| 类型安全 | ❌ | ✅ |
| 流式传输 | ❌ | ✅ |
| 适用场景 | 对外API | 内部高性能 |

**当前项目选择HTTP的原因**:
- ✅ 简单易用，无需proto文件
- ✅ 调试方便（curl, Postman）
- ✅ 性能足够（非极端高并发）
- ✅ 统一技术栈（都是HTTP）

## 🎯 最佳实践

### 1. 服务命名规范

```
Consul服务名 = {模块}service
例如:
- testservice
- basicservice
- userservice
```

### 2. 接口路径规范

```
/{模块}/{资源}/{操作}
例如:
- /basic/color/1     (获取颜色)
- /admin/user/list   (用户列表)
```

### 3. 错误处理

```go
// 服务A调用服务B时统一处理
type ServiceResponse struct {
    Code int         `json:"code"`
    Msg  string      `json:"msg"`
    Data interface{} `json:"data"`
}

var resp ServiceResponse
err := httpClient.CallService(...)

if resp.Code != 0 {
    return fmt.Errorf("服务B返回错误: %s", resp.Msg)
}
```

### 4. 日志记录

```go
import "log"

log.Printf("[服务调用] 调用 %s 服务, 路径: %s", serviceName, path)
err := httpClient.CallService(...)
if err != nil {
    log.Printf("[服务调用失败] 服务: %s, 错误: %v", serviceName, err)
}
```

## 📝 总结

### 通讯方式汇总

| 场景 | 方式 | 说明 |
|------|------|------|
| 前端→后端 | HTTP + 网关 | 统一入口、认证 |
| 服务A→服务B | HTTP + Consul | 服务发现 |
| 网关→服务 | HTTP反向代理 | 路由转发 |

### 关键点

1. ✅ 使用 `ServiceClient` 封装HTTP调用
2. ✅ 通过Consul自动发现服务地址
3. ✅ 统一错误处理和响应格式
4. ✅ 支持超时、重试机制
5. ✅ 传递认证信息（Header）

---

**相关文档**:
- [架构说明](架构说明.md)
- [API网关指南](API网关指南.md)
- [Consul集成指南](Consul集成指南.md)


