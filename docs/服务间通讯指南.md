# æœåŠ¡é—´é€šè®¯æŒ‡å—

## ğŸ“– æ¦‚è¿°

Mule-Cloudé¡¹ç›®ä½¿ç”¨ **HTTP + ConsulæœåŠ¡å‘ç°** è¿›è¡ŒæœåŠ¡é—´é€šè®¯ã€‚

## ğŸ—ï¸ é€šè®¯æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å‰ç«¯/å®¢æˆ·ç«¯ â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ â‘  HTTP + JWT
       â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    APIç½‘å…³ (:8080)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ â‘¡ HTTP (æœåŠ¡å‘ç°)
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â†“              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TestæœåŠ¡   â”‚  â”‚ BasicæœåŠ¡  â”‚
â”‚  (:8000)   â”‚â†â‘¢â”‚  (:8001)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  HTTPè°ƒç”¨ï¼ˆæœåŠ¡é—´ï¼‰
       â†‘
       â””â”€â”€ ConsulæœåŠ¡å‘ç°
```

## ğŸ”„ ä¸‰ç§é€šè®¯æ–¹å¼

### 1. å®¢æˆ·ç«¯ â†’ ç½‘å…³ â†’ æœåŠ¡

**åœºæ™¯**: å‰ç«¯æˆ–å¤–éƒ¨å®¢æˆ·ç«¯è®¿é—®å¾®æœåŠ¡

```bash
# å®¢æˆ·ç«¯è¯·æ±‚
curl -H "Authorization: Bearer {token}" \
  http://localhost:8080/test/admin/1

# æµç¨‹:
å‰ç«¯ â†’ ç½‘å…³(:8080) â†’ ConsulæŸ¥æ‰¾"testservice" â†’ è½¬å‘åˆ°testæœåŠ¡(:8000)
```

**ç‰¹ç‚¹**:
- âœ… ç»Ÿä¸€å…¥å£
- âœ… ç»Ÿä¸€è®¤è¯
- âœ… é™æµä¿æŠ¤

### 2. æœåŠ¡A â†’ æœåŠ¡B (HTTPè°ƒç”¨)

**åœºæ™¯**: å¾®æœåŠ¡ä¹‹é—´éœ€è¦äº’ç›¸è°ƒç”¨

**ç¤ºä¾‹**: TestæœåŠ¡è°ƒç”¨BasicæœåŠ¡è·å–é¢œè‰²ä¿¡æ¯

```go
// test/services/user.go

// 1. åˆ›å»ºHTTPå®¢æˆ·ç«¯
httpClient, _ := httpclient.NewServiceClient("127.0.0.1:8500")

// 2. è°ƒç”¨å…¶ä»–æœåŠ¡
var colorResp ColorResponse
err := httpClient.CallService(
    ctx,
    "GET",
    "basicservice",        // æœåŠ¡åï¼ˆConsulä¸­æ³¨å†Œçš„åå­—ï¼‰
    "/basic/color/1",      // è·¯å¾„
    nil,                   // è¯·æ±‚ä½“
    &colorResp,            // å“åº”æ•°æ®
    nil,                   // é¢å¤–headers
)

// 3. ä½¿ç”¨å“åº”æ•°æ®
if colorResp.Code == 0 {
    color := colorResp.Data.Color
    // ä¸šåŠ¡é€»è¾‘...
}
```

**æµç¨‹**:
```
TestæœåŠ¡ â†’ ConsulæŸ¥æ‰¾"basicservice" 
         â†’ è·å–åœ°å€(192.168.31.78:8001) 
         â†’ HTTP GET /basic/color/1 
         â†’ BasicæœåŠ¡å¤„ç†å¹¶è¿”å›
```

### 3. ç½‘å…³ â†’ æœåŠ¡ (åå‘ä»£ç†)

**åœºæ™¯**: ç½‘å…³è½¬å‘è¯·æ±‚åˆ°åç«¯æœåŠ¡

```go
// gateway/main.go

// ç½‘å…³è‡ªåŠ¨ä»Consulè·å–æœåŠ¡åœ°å€å¹¶è½¬å‘
targetURL, _ := gw.getServiceAddress("testservice")
proxy := httputil.NewSingleHostReverseProxy(target)
proxy.ServeHTTP(c.Writer, c.Request)
```

## ğŸ› ï¸ å®ç°æ–¹å¼

### æ–¹å¼1: ä½¿ç”¨å°è£…çš„ ServiceClientï¼ˆæ¨èï¼‰

**ä¼˜ç‚¹**: 
- âœ… è‡ªåŠ¨æœåŠ¡å‘ç°
- âœ… ç»Ÿä¸€é”™è¯¯å¤„ç†
- âœ… ç®€å•æ˜“ç”¨

```go
// 1. åˆ›å»ºå®¢æˆ·ç«¯
import "mule-cloud/core/httpclient"

client, err := httpclient.NewServiceClient("127.0.0.1:8500")

// 2. GETè¯·æ±‚
respBody, err := client.Get(ctx, "basicservice", "/basic/color/1", nil)

// 3. POSTè¯·æ±‚
reqData := map[string]interface{}{
    "name": "æµ‹è¯•",
    "email": "test@example.com",
}
respBody, err := client.Post(ctx, "testservice", "/admin", reqData, nil)

// 4. è‡ªåŠ¨è§£æå“åº”
type Response struct {
    Code int         `json:"code"`
    Data interface{} `json:"data"`
}
var resp Response
err := client.CallService(ctx, "GET", "basicservice", "/basic/color/1", nil, &resp, nil)
```

### æ–¹å¼2: æ‰‹åŠ¨å®ç°

```go
import (
    "github.com/hashicorp/consul/api"
    "net/http"
)

// 1. è¿æ¥Consul
config := api.DefaultConfig()
config.Address = "127.0.0.1:8500"
consulClient, _ := api.NewClient(config)

// 2. æŸ¥è¯¢æœåŠ¡
services, _, _ := consulClient.Health().Service("basicservice", "", true, nil)
service := services[0].Service
baseURL := fmt.Sprintf("http://%s:%d", service.Address, service.Port)

// 3. å‘é€HTTPè¯·æ±‚
resp, _ := http.Get(baseURL + "/basic/color/1")
defer resp.Body.Close()

// 4. å¤„ç†å“åº”
body, _ := io.ReadAll(resp.Body)
```

## ğŸ“ å®Œæ•´ç¤ºä¾‹

### åœºæ™¯: TestæœåŠ¡è·å–ç”¨æˆ·å–œæ¬¢çš„é¢œè‰²

#### 1. Serviceå±‚ï¼ˆä¸šåŠ¡é€»è¾‘ï¼‰

```go
// test/services/user.go
package services

import (
    "context"
    "mule-cloud/core/httpclient"
)

type UserService struct {
    httpClient *httpclient.ServiceClient
}

func NewUserService(consulAddr string) IUserService {
    client, _ := httpclient.NewServiceClient(consulAddr)
    return &UserService{httpClient: client}
}

func (s *UserService) GetUserWithColor(userID string) (*UserWithColorInfo, error) {
    // 1. æœ¬åœ°æ•°æ®
    user := &UserWithColorInfo{
        UserID:   userID,
        Username: "user_" + userID,
    }

    // 2. è°ƒç”¨basicæœåŠ¡
    ctx := context.Background()
    var colorResp ColorResponse
    
    err := s.httpClient.CallService(
        ctx,
        "GET",
        "basicservice",      // ç›®æ ‡æœåŠ¡
        "/basic/color/1",    // æ¥å£è·¯å¾„
        nil,
        &colorResp,
        nil,
    )

    if err != nil {
        return nil, err
    }

    // 3. ç»„åˆæ•°æ®
    user.FavoriteColor = colorResp.Data.Color
    return user, nil
}
```

#### 2. Endpointå±‚

```go
// test/endpoint/user.go
func GetUserWithColorEndpoint(svc services.IUserService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(UserRequest)
        user, err := svc.GetUserWithColor(req.ID)
        if err != nil {
            return nil, err
        }
        return UserResponse{User: user}, nil
    }
}
```

#### 3. Transportå±‚

```go
// test/transport/user.go
func GetUserWithColorHandler(svc services.IUserService) gin.HandlerFunc {
    return func(c *gin.Context) {
        var req endpoint.UserRequest
        if err := c.ShouldBindUri(&req); err != nil {
            response.Error(c, "å‚æ•°é”™è¯¯")
            return
        }

        ep := endpoint.GetUserWithColorEndpoint(svc)
        resp, err := ep(c.Request.Context(), req)
        if err != nil {
            response.Error(c, err.Error())
            return
        }

        response.Success(c, resp)
    }
}
```

#### 4. æ³¨å†Œè·¯ç”±

```go
// test/cmd/main.go
func main() {
    // åˆ›å»ºæœåŠ¡ï¼ˆä¼ å…¥Consulåœ°å€ï¼‰
    userSvc := services.NewUserService("127.0.0.1:8500")

    r := gin.Default()
    
    user := r.Group("/user")
    {
        user.GET("/:id", transport.GetUserWithColorHandler(userSvc))
    }

    r.Run(":8000")
}
```

#### 5. æµ‹è¯•

```bash
# é€šè¿‡ç½‘å…³è®¿é—®
curl http://localhost:8080/test/user/123

# å“åº”
{
  "code": 0,
  "msg": "success",
  "data": {
    "user": {
      "user_id": "123",
      "username": "user_123",
      "favorite_color": {
        "id": "1",
        "name": "çº¢è‰²",
        "hex_code": "#FF0000"
      }
    }
  }
}
```

## ğŸ”’ è®¤è¯ä¼ é€’

### åœºæ™¯: æœåŠ¡é—´è°ƒç”¨éœ€è¦ä¼ é€’ç”¨æˆ·ä¿¡æ¯

```go
// ä»ç½‘å…³è·å–ç”¨æˆ·ä¿¡æ¯
userID := c.GetHeader("X-User-ID")
username := c.GetHeader("X-Username")

// è°ƒç”¨å…¶ä»–æœåŠ¡æ—¶ä¼ é€’
headers := map[string]string{
    "X-User-ID": userID,
    "X-Username": username,
}

err := httpClient.CallService(
    ctx,
    "POST",
    "otherservice",
    "/some/path",
    reqData,
    &respData,
    headers,  // ä¼ é€’ç”¨æˆ·ä¿¡æ¯
)
```

## âš¡ æ€§èƒ½ä¼˜åŒ–

### 1. è¿æ¥å¤ç”¨

```go
// åœ¨æœåŠ¡åˆå§‹åŒ–æ—¶åˆ›å»ºä¸€æ¬¡
type MyService struct {
    httpClient *httpclient.ServiceClient  // å¤ç”¨è¿æ¥
}

func NewMyService(consulAddr string) *MyService {
    client, _ := httpclient.NewServiceClient(consulAddr)
    return &MyService{httpClient: client}
}
```

### 2. è¶…æ—¶æ§åˆ¶

```go
// è®¾ç½®è¶…æ—¶
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

err := httpClient.CallService(ctx, "GET", "service", "/path", nil, &resp, nil)
```

### 3. å¹¶å‘è°ƒç”¨

```go
// åŒæ—¶è°ƒç”¨å¤šä¸ªæœåŠ¡
var wg sync.WaitGroup
var color *ColorInfo
var size *SizeInfo

// è°ƒç”¨é¢œè‰²æœåŠ¡
wg.Add(1)
go func() {
    defer wg.Done()
    httpClient.CallService(ctx, "GET", "basicservice", "/basic/color/1", nil, &color, nil)
}()

// è°ƒç”¨å°ºå¯¸æœåŠ¡
wg.Add(1)
go func() {
    defer wg.Done()
    httpClient.CallService(ctx, "GET", "basicservice", "/basic/size/1", nil, &size, nil)
}()

wg.Wait()
```

## ğŸ› é”™è¯¯å¤„ç†

### 1. æœåŠ¡ä¸å¯ç”¨

```go
err := httpClient.CallService(...)
if err != nil {
    if strings.Contains(err.Error(), "æœªæ‰¾åˆ°æœåŠ¡") {
        // æœåŠ¡æœªæ³¨å†Œåˆ°Consul
        return fmt.Errorf("æœåŠ¡æš‚æ—¶ä¸å¯ç”¨")
    }
    return err
}
```

### 2. è¶…æ—¶å¤„ç†

```go
ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
defer cancel()

err := httpClient.CallService(ctx, ...)
if err != nil {
    if ctx.Err() == context.DeadlineExceeded {
        // è¶…æ—¶
        return fmt.Errorf("è°ƒç”¨æœåŠ¡è¶…æ—¶")
    }
}
```

### 3. é‡è¯•æœºåˆ¶

```go
func callWithRetry(fn func() error, maxRetries int) error {
    var err error
    for i := 0; i < maxRetries; i++ {
        err = fn()
        if err == nil {
            return nil
        }
        time.Sleep(time.Duration(i+1) * 100 * time.Millisecond)
    }
    return fmt.Errorf("é‡è¯•%dæ¬¡åå¤±è´¥: %v", maxRetries, err)
}

// ä½¿ç”¨
err := callWithRetry(func() error {
    return httpClient.CallService(...)
}, 3)
```

## ğŸ“Š å¯¹æ¯”ï¼šHTTP vs gRPC

| ç‰¹æ€§ | HTTP/REST | gRPC |
|------|-----------|------|
| æ€§èƒ½ | â­â­â­ | â­â­â­â­â­ |
| æ˜“ç”¨æ€§ | â­â­â­â­â­ | â­â­â­ |
| è°ƒè¯• | â­â­â­â­â­ | â­â­ |
| æµè§ˆå™¨æ”¯æŒ | âœ… | âŒ |
| ç±»å‹å®‰å…¨ | âŒ | âœ… |
| æµå¼ä¼ è¾“ | âŒ | âœ… |
| é€‚ç”¨åœºæ™¯ | å¯¹å¤–API | å†…éƒ¨é«˜æ€§èƒ½ |

**å½“å‰é¡¹ç›®é€‰æ‹©HTTPçš„åŸå› **:
- âœ… ç®€å•æ˜“ç”¨ï¼Œæ— éœ€protoæ–‡ä»¶
- âœ… è°ƒè¯•æ–¹ä¾¿ï¼ˆcurl, Postmanï¼‰
- âœ… æ€§èƒ½è¶³å¤Ÿï¼ˆéæç«¯é«˜å¹¶å‘ï¼‰
- âœ… ç»Ÿä¸€æŠ€æœ¯æ ˆï¼ˆéƒ½æ˜¯HTTPï¼‰

## ğŸ¯ æœ€ä½³å®è·µ

### 1. æœåŠ¡å‘½åè§„èŒƒ

```
ConsulæœåŠ¡å = {æ¨¡å—}service
ä¾‹å¦‚:
- testservice
- basicservice
- userservice
```

### 2. æ¥å£è·¯å¾„è§„èŒƒ

```
/{æ¨¡å—}/{èµ„æº}/{æ“ä½œ}
ä¾‹å¦‚:
- /basic/color/1     (è·å–é¢œè‰²)
- /admin/user/list   (ç”¨æˆ·åˆ—è¡¨)
```

### 3. é”™è¯¯å¤„ç†

```go
// æœåŠ¡Aè°ƒç”¨æœåŠ¡Bæ—¶ç»Ÿä¸€å¤„ç†
type ServiceResponse struct {
    Code int         `json:"code"`
    Msg  string      `json:"msg"`
    Data interface{} `json:"data"`
}

var resp ServiceResponse
err := httpClient.CallService(...)

if resp.Code != 0 {
    return fmt.Errorf("æœåŠ¡Bè¿”å›é”™è¯¯: %s", resp.Msg)
}
```

### 4. æ—¥å¿—è®°å½•

```go
import "log"

log.Printf("[æœåŠ¡è°ƒç”¨] è°ƒç”¨ %s æœåŠ¡, è·¯å¾„: %s", serviceName, path)
err := httpClient.CallService(...)
if err != nil {
    log.Printf("[æœåŠ¡è°ƒç”¨å¤±è´¥] æœåŠ¡: %s, é”™è¯¯: %v", serviceName, err)
}
```

## ğŸ“ æ€»ç»“

### é€šè®¯æ–¹å¼æ±‡æ€»

| åœºæ™¯ | æ–¹å¼ | è¯´æ˜ |
|------|------|------|
| å‰ç«¯â†’åç«¯ | HTTP + ç½‘å…³ | ç»Ÿä¸€å…¥å£ã€è®¤è¯ |
| æœåŠ¡Aâ†’æœåŠ¡B | HTTP + Consul | æœåŠ¡å‘ç° |
| ç½‘å…³â†’æœåŠ¡ | HTTPåå‘ä»£ç† | è·¯ç”±è½¬å‘ |

### å…³é”®ç‚¹

1. âœ… ä½¿ç”¨ `ServiceClient` å°è£…HTTPè°ƒç”¨
2. âœ… é€šè¿‡Consulè‡ªåŠ¨å‘ç°æœåŠ¡åœ°å€
3. âœ… ç»Ÿä¸€é”™è¯¯å¤„ç†å’Œå“åº”æ ¼å¼
4. âœ… æ”¯æŒè¶…æ—¶ã€é‡è¯•æœºåˆ¶
5. âœ… ä¼ é€’è®¤è¯ä¿¡æ¯ï¼ˆHeaderï¼‰

---

**ç›¸å…³æ–‡æ¡£**:
- [æ¶æ„è¯´æ˜](æ¶æ„è¯´æ˜.md)
- [APIç½‘å…³æŒ‡å—](APIç½‘å…³æŒ‡å—.md)
- [Consulé›†æˆæŒ‡å—](Consulé›†æˆæŒ‡å—.md)


