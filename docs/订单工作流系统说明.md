# 订单工作流系统说明

## 📋 概述

基于 Redis 的订单工作流系统，用于管理订单状态流转，减轻数据库压力，提供状态历史追溯功能。

## 🎯 核心特性

### 1. 状态管理
- **状态定义**：
  - 0: 草稿
  - 1: 已下单
  - 2: 生产中
  - 3: 已完成
  - 4: 已取消

### 2. 事件驱动
- `submit_order`: 提交订单（草稿 → 已下单）
- `start_cutting`: 开始裁剪（已下单 → 生产中）
- `start_production`: 开始生产（已下单 → 生产中）
- `update_progress`: 更新进度（保持生产中状态）
- `complete`: 完成订单（生产中 → 已完成）
- `cancel`: 取消订单（任意状态 → 已取消）

### 3. Redis 缓存策略
- **状态缓存**: `order:status:{order_id}` - 缓存 24 小时
- **历史记录**: `order:history:{order_id}` - 保留最近 100 条，90 天过期

## 🔄 状态流转规则

```
草稿 (0)
  ├─ submit_order → 已下单 (1)
  └─ cancel → 已取消 (4)

已下单 (1)
  ├─ start_cutting → 生产中 (2)
  ├─ start_production → 生产中 (2)
  └─ cancel → 已取消 (4)

生产中 (2)
  ├─ update_progress → 生产中 (2)
  ├─ complete → 已完成 (3)
  └─ cancel → 已取消 (4)

已完成 (3)
  └─ (终态)

已取消 (4)
  └─ (终态)
```

## 💻 使用方法

### 初始化

```go
import "mule-cloud/core/workflow"

wf := workflow.NewOrderWorkflow()
```

### 状态转换

```go
// 1. 创建裁剪任务时
err := wf.StartCutting(ctx, orderID, "操作员")

// 2. 开始制菲时
err := wf.StartProduction(ctx, orderID, "操作员", "制菲开始")

// 3. 更新生产进度时
err := wf.UpdateProgress(ctx, orderID, 0.5, "操作员") // 50%

// 4. 完成订单时
err := wf.CompleteOrder(ctx, orderID, "操作员", "所有工序完成")

// 5. 取消订单时
err := wf.CancelOrder(ctx, orderID, "操作员", "客户取消")
```

### 查询状态

```go
// 获取当前状态（优先从 Redis）
status, err := wf.GetCurrentStatus(ctx, orderID)

// 获取状态历史
histories, err := wf.GetHistory(ctx, orderID, 10) // 最近10条
```

### 手动控制

```go
// 检查是否可以转换
canTransition := wf.CanTransition(currentStatus, workflow.EventComplete)

// 获取下一个状态
nextStatus, err := wf.GetNextStatus(currentStatus, workflow.EventComplete)

// 通用状态转换（带元数据）
err := wf.TransitionTo(ctx, orderID, workflow.EventComplete, "操作员", "完成原因", map[string]interface{}{
    "total_pieces": 1000,
    "quality_score": 98.5,
})
```

## 🔧 集成示例

### 裁剪服务集成

```go
// app/order/services/cutting.go

type cuttingService struct {
    // ...
    workflow *workflow.OrderWorkflow
}

func NewCuttingService(...) ICuttingService {
    return &cuttingService{
        // ...
        workflow: workflow.NewOrderWorkflow(),
    }
}

func (s *cuttingService) CreateCuttingTask(ctx context.Context, req *dto.CuttingTaskCreateRequest) (*models.CuttingTask, error) {
    // 创建任务...
    
    // 使用工作流更新状态
    _ = s.workflow.StartCutting(ctx, orderID, req.CreatedBy)
    
    return task, nil
}
```

### 生产上报服务集成

```go
// app/production/services/report.go

func (s *reportService) updateOrderProgress(ctx context.Context, orderID string) {
    // 计算总体进度
    newProgress := overallProgress / 100.0
    
    // 获取操作员
    operator := corecontext.GetUsername(ctx)
    
    // 使用工作流更新进度和状态
    _ = s.workflow.UpdateProgress(ctx, orderID, newProgress, operator)
}
```

## 📊 状态历史记录

每次状态转换都会记录到 Redis，包含以下信息：

```json
{
  "order_id": "68e48c19b4eb03ee2a2b8dcd",
  "from_state": 1,
  "to_state": 2,
  "event": "start_cutting",
  "reason": "创建裁剪任务",
  "operator": "admin",
  "timestamp": 1729234567,
  "metadata": {
    "task_id": "xxx"
  }
}
```

## 🚀 优势

### 1. 性能优化
- ✅ Redis 缓存减少数据库查询
- ✅ 状态查询毫秒级响应
- ✅ 批量操作时避免频繁数据库更新

### 2. 可追溯性
- ✅ 完整的状态变更历史
- ✅ 记录操作人和操作原因
- ✅ 支持审计和问题排查

### 3. 可维护性
- ✅ 集中管理状态流转规则
- ✅ 规则变更无需修改多处代码
- ✅ 防止非法状态转换

### 4. 可扩展性
- ✅ 支持自定义事件和状态
- ✅ 支持状态转换钩子
- ✅ 元数据支持任意业务信息

## ⚠️ 注意事项

1. **Redis 依赖**: 需要确保 Redis 服务正常运行
2. **数据一致性**: 状态最终会同步到 MongoDB
3. **缓存失效**: 可使用 `InvalidateCache()` 手动清除缓存
4. **并发控制**: 状态转换需要考虑并发场景（后续可添加分布式锁）

## 🔮 未来扩展

- [ ] 添加分布式锁防止并发冲突
- [ ] 支持状态转换前置/后置钩子
- [ ] 支持工作流可视化
- [ ] 支持复杂的条件转换规则
- [ ] 支持状态回滚功能

