# 不分扎工序上报实施方案

## 📋 概述

本方案旨在实现订单工序的完整上报流程，特别是处理"不分扎"和"分扎"两种不同的工序上报逻辑。工序上报功能将主要在**小程序端**实现，供车间工人使用。

---

## 🎯 业务背景

### 什么是"分扎"和"不分扎"

**分扎工序（正常工序）**
- 需要按照扎号（BundleNo）分别上报
- 每一扎的进度独立追踪
- 例如：缝纫、锁边等主要工序
- 工人扫描扎号二维码后上报该扎的完成数量

**不分扎工序**
- 不需要按扎号上报，按整个订单或批次上报
- 通常是质检、整烫等辅助工序
- 工人可以一次性上报多个扎的该工序完成情况
- 提高上报效率

### 业务流程

```
订单创建 → 选择款式（带工序） → 配置工序（标记不分扎）
    ↓
裁剪任务创建 → 生成裁剪批次（制菲）→ 打印扎号二维码
    ↓
创建工序进度记录：
  - 分扎工序：每个扎的每个尺码创建独立记录
  - 不分扎工序：整个订单只创建一条记录
    ↓
工人扫码上报（小程序）：
  - 分扎工序：扫扎号二维码 → 上报该扎数量
  - 不分扎工序：选择订单 → 上报总数量
    ↓
系统计算进度 → 更新订单完成度
```

---

## ✅ 已完成的工作

### 1. 数据模型设计 ✓

**工序进度表 (procedure_progress)**
```go
type ProcedureProgress struct {
    ID             string  // 进度记录ID
    OrderID        string  // 订单ID
    ContractNo     string  // 合同号
    StyleNo        string  // 款号
    BedNo          string  // 床号（不分扎为空）
    BundleNo       string  // 扎号（不分扎为空）
    Color          string  // 颜色（不分扎为空）
    Size           string  // 尺码（不分扎为空）
    Sequence       int     // 工序顺序
    ProcedureName  string  // 工序名称
    NoBundle       bool    // 是否不分扎 ⭐核心字段
    WorkerName     string  // 工人名称
    Quantity       int     // 已上报数量
    UnitPrice      float64 // 工价
    TotalAmount    float64 // 总金额（数量×工价）
    Status         int     // 状态：0-未开始 1-进行中 2-已完成
    CompletedAt    int64   // 完成时间
    ReportedBy     string  // 上报人
    ReportedAt     int64   // 上报时间
    CreatedAt      int64   // 创建时间
}
```

### 2. Repository 层实现 ✓

**已实现的方法：**
- `Create()` - 创建单条记录
- `BatchCreate()` - 批量创建记录
- `Update()` - 更新记录
- `GetByID()` - 根据ID查询
- `List()` - 分页列表查询
- `GetByBundleAndProcedure()` - 根据扎号和工序查询
- `GetByOrderAndProcedure()` - 根据订单和工序查询（用于不分扎）

### 3. 工序进度记录自动创建 ✓

**在创建裁剪批次时自动创建：**

```go
// app/order/services/cutting.go - CreateCuttingBatch() 方法

for _, procedure := range order.Procedures {
    if procedure.NoBundle {
        // 不分扎工序：整个订单只创建一条记录
        progress := &models.ProcedureProgress{
            OrderID:       task.OrderID,
            BundleNo:      "",  // 空
            NoBundle:      true,
            Sequence:      procedure.Sequence,
            ProcedureName: procedure.ProcedureName,
            // ...
        }
    } else {
        // 分扎工序：每个扎的每个尺码创建一条记录
        for _, size := range req.SizeDetails {
            progress := &models.ProcedureProgress{
                OrderID:       task.OrderID,
                BundleNo:      req.BundleNo,
                Color:         req.Color,
                Size:          size.Size,
                NoBundle:      false,
                // ...
            }
        }
    }
}
```

---

## 📝 待实现功能（后端）

### 1. Service 层 - 工序上报业务逻辑

**需要添加到 `app/order/services/cutting.go`：**

```go
// ReportProcedureProgress 工序上报
func (s *cuttingService) ReportProcedureProgress(
    ctx context.Context, 
    req *dto.ProcedureProgressReportRequest,
) (*models.ProcedureProgress, error) {
    
    // 1. 获取订单信息，验证工序
    order, err := s.orderRepo.Get(ctx, req.OrderID)
    if err != nil {
        return nil, fmt.Errorf("订单不存在")
    }
    
    // 查找对应的工序
    var procedure *models.OrderProcedure
    for _, p := range order.Procedures {
        if p.Sequence == req.Sequence {
            procedure = &p
            break
        }
    }
    if procedure == nil {
        return nil, fmt.Errorf("工序不存在")
    }
    
    // 2. 根据是否分扎，查找或创建进度记录
    var progress *models.ProcedureProgress
    
    if procedure.NoBundle {
        // 不分扎工序：查找订单级别的进度记录
        progressList, err := s.progressRepo.GetByOrderAndProcedure(ctx, req.OrderID, req.Sequence)
        if err != nil || len(progressList) == 0 {
            return nil, fmt.Errorf("工序进度记录不存在")
        }
        progress = progressList[0]
    } else {
        // 分扎工序：查找扎号级别的进度记录
        if req.BundleNo == "" {
            return nil, fmt.Errorf("分扎工序必须提供扎号")
        }
        progress, err = s.progressRepo.GetByBundleAndProcedure(ctx, req.OrderID, req.BundleNo, req.Sequence)
        if err != nil {
            return nil, fmt.Errorf("该扎的工序进度记录不存在")
        }
    }
    
    // 3. 更新进度记录
    now := time.Now().Unix()
    progress.WorkerName = req.WorkerName
    progress.Quantity += req.Quantity  // 累加数量
    progress.TotalAmount = float64(progress.Quantity) * progress.UnitPrice
    progress.Status = 1  // 进行中
    progress.ReportedBy = req.ReportedBy
    progress.ReportedAt = now
    
    // 判断是否完成（需要根据实际业务判断）
    // TODO: 获取该工序应完成的总数量，判断是否已全部完成
    
    err = s.progressRepo.Update(ctx, progress.ID, progress)
    if err != nil {
        return nil, err
    }
    
    // 4. 更新订单整体进度
    // TODO: 计算订单所有工序的完成百分比
    
    return progress, nil
}

// GetProcedureProgressList 获取工序进度列表
func (s *cuttingService) GetProcedureProgressList(
    ctx context.Context, 
    req *dto.ProcedureProgressListRequest,
) ([]*models.ProcedureProgress, int64, error) {
    return s.progressRepo.List(ctx, req.Page, req.PageSize, req.OrderID, req.BundleNo, req.ProcedureName)
}

// GetProcedureProgressByID 根据ID获取工序进度
func (s *cuttingService) GetProcedureProgressByID(
    ctx context.Context, 
    id string,
) (*models.ProcedureProgress, error) {
    return s.progressRepo.GetByID(ctx, id)
}
```

### 2. Endpoint 层

**需要创建 `app/order/endpoint/procedure.go`：**

```go
package endpoint

import (
    "context"
    "mule-cloud/app/order/dto"
    "mule-cloud/app/order/services"
    "github.com/go-kit/kit/endpoint"
)

// MakeProcedureProgressReportEndpoint 工序上报端点
func MakeProcedureProgressReportEndpoint(s services.ICuttingService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(*dto.ProcedureProgressReportRequest)
        progress, err := s.ReportProcedureProgress(ctx, req)
        if err != nil {
            return nil, err
        }
        return &dto.ProcedureProgressResponse{Progress: progress}, nil
    }
}

// MakeProcedureProgressListEndpoint 工序进度列表端点
func MakeProcedureProgressListEndpoint(s services.ICuttingService) endpoint.Endpoint {
    return func(ctx context.Context, request interface{}) (interface{}, error) {
        req := request.(*dto.ProcedureProgressListRequest)
        progressList, total, err := s.GetProcedureProgressList(ctx, req)
        if err != nil {
            return nil, err
        }
        return &dto.ProcedureProgressListResponse{
            ProgressList: progressList,
            Total:        total,
        }, nil
    }
}
```

### 3. Transport 层（HTTP API）

**需要在 `app/order/transport/cutting.go` 添加路由：**

```go
// 工序进度相关路由
{
    cutting := orderGroup.Group("/cutting")
    
    // 工序上报（小程序端使用）
    cutting.POST("/procedures/report", 
        core_middleware.ApplyMiddleware(
            gin.HandlerFunc(cuttingTransport.ReportProcedureProgress),
            "工序上报",
        ),
    )
    
    // 工序进度列表（管理端查询）
    cutting.GET("/procedures/progress", 
        core_middleware.ApplyMiddleware(
            gin.HandlerFunc(cuttingTransport.GetProcedureProgressList),
            "工序进度列表",
        ),
    )
    
    // 工序进度详情
    cutting.GET("/procedures/progress/:id", 
        core_middleware.ApplyMiddleware(
            gin.HandlerFunc(cuttingTransport.GetProcedureProgressByID),
            "工序进度详情",
        ),
    )
}
```

---

## 📱 小程序端实现方案

### 1. 功能页面设计

#### 页面1：扫码上报（主页面）

**扫码入口**
```
┌─────────────────────────┐
│   📷 扫描扎号二维码      │
└─────────────────────────┘
         或
┌─────────────────────────┐
│   📋 手动选择订单上报    │
└─────────────────────────┘
```

#### 页面2：工序上报表单

**分扎工序上报：**
```
订单信息
├─ 合同号：202510067553
├─ 款号：0031214
├─ 床号：01
├─ 扎号：001
├─ 颜色：蓝色
└─ 尺码：L

请选择工序：
[ ] 1. 缝纫 (¥0.50/件)
[√] 2. 锁边 (¥0.30/件)  ← 当前选中
[ ] 3. 质检 (不分扎)

完成数量：[____] 件

工人姓名：[张三▼]

[确认上报]
```

**不分扎工序上报：**
```
订单信息
├─ 合同号：202510067553
├─ 款号：0031214
└─ 客户：XX服装厂

请选择工序：
[ ] 1. 缝纫 (分扎)
[ ] 2. 锁边 (分扎)
[√] 3. 质检 (¥0.20/件) ← 不分扎工序

完成数量：[____] 件
（可一次性上报多个扎）

工人姓名：[李四▼]

[确认上报]
```

### 2. 小程序API接口

**接口1：工序上报**
```
POST /order/cutting/procedures/report

Request Body:
{
  "order_id": "订单ID",
  "bundle_no": "扎号（不分扎工序留空）",
  "sequence": 2,
  "worker_name": "张三",
  "quantity": 100,
  "reported_by": "用户ID"
}

Response:
{
  "code": 200,
  "message": "上报成功",
  "data": {
    "progress": {
      "id": "进度记录ID",
      "order_id": "订单ID",
      "bundle_no": "001",
      "procedure_name": "锁边",
      "quantity": 100,
      "total_amount": 30.00,
      "status": 1
    }
  }
}
```

**接口2：获取订单工序列表**
```
GET /order/orders/:id

Response 包含工序信息：
{
  "procedures": [
    {
      "sequence": 1,
      "procedure_name": "缝纫",
      "unit_price": 0.5,
      "no_bundle": false
    },
    {
      "sequence": 3,
      "procedure_name": "质检",
      "unit_price": 0.2,
      "no_bundle": true  ← 不分扎标记
    }
  ]
}
```

**接口3：查询工序进度（查看已上报记录）**
```
GET /order/cutting/procedures/progress?order_id=xxx&bundle_no=001

Response:
{
  "progress_list": [
    {
      "procedure_name": "锁边",
      "worker_name": "张三",
      "quantity": 100,
      "reported_at": 1696838400
    }
  ],
  "total": 1
}
```

### 3. 小程序实现要点

**扫码逻辑**
```javascript
// 扫描二维码
wx.scanCode({
  success: (res) => {
    const qrData = JSON.parse(res.result);
    // qrData 包含：order_id, bundle_no, bed_no, color, sizes 等信息
    
    // 跳转到上报页面
    wx.navigateTo({
      url: `/pages/report/index?data=${encodeURIComponent(res.result)}`
    });
  }
});
```

**上报表单逻辑**
```javascript
// 提交上报
async function submitReport() {
  const data = {
    order_id: currentOrder.id,
    bundle_no: isNoBundle ? '' : currentBundle.bundle_no,
    sequence: selectedProcedure.sequence,
    worker_name: workerName,
    quantity: parseInt(quantity),
    reported_by: getCurrentUserId()
  };
  
  const res = await request.post('/order/cutting/procedures/report', data);
  
  if (res.code === 200) {
    wx.showToast({ title: '上报成功' });
    // 清空表单或返回
  }
}
```

**区分分扎和不分扎**
```javascript
// 根据工序的 no_bundle 字段判断
const procedureList = order.procedures.map(p => ({
  ...p,
  label: p.procedure_name + (p.no_bundle ? ' (不分扎)' : ''),
  disabled: !p.no_bundle && !hasBundleNo  // 分扎工序必须有扎号
}));
```

---

## 🔧 进度计算逻辑

### 订单整体进度计算

```go
// 计算订单完成百分比
func CalculateOrderProgress(ctx context.Context, orderID string) (float64, error) {
    // 1. 获取订单所有工序
    order, _ := orderRepo.Get(ctx, orderID)
    
    // 2. 获取所有工序进度记录
    allProgress, _ := progressRepo.List(ctx, 1, 1000, orderID, "", "")
    
    // 3. 计算每个工序的完成率
    procedureCompletionRates := make(map[int]float64)
    
    for _, procedure := range order.Procedures {
        var completedQty, totalQty int
        
        if procedure.NoBundle {
            // 不分扎工序：查找该工序的唯一记录
            for _, p := range allProgress {
                if p.Sequence == procedure.Sequence {
                    completedQty = p.Quantity
                    break
                }
            }
            totalQty = order.Quantity  // 订单总数量
        } else {
            // 分扎工序：汇总所有扎的完成数量
            for _, p := range allProgress {
                if p.Sequence == procedure.Sequence {
                    completedQty += p.Quantity
                }
            }
            totalQty = order.Quantity
        }
        
        if totalQty > 0 {
            procedureCompletionRates[procedure.Sequence] = float64(completedQty) / float64(totalQty) * 100
        }
    }
    
    // 4. 取最慢工序的进度作为订单进度
    var slowestProgress float64 = 100
    for _, rate := range procedureCompletionRates {
        if rate < slowestProgress {
            slowestProgress = rate
        }
    }
    
    return slowestProgress, nil
}
```

---

## 📊 数据库索引优化

```javascript
// MongoDB 索引建议
db.procedure_progress.createIndex({ "order_id": 1, "sequence": 1 });
db.procedure_progress.createIndex({ "order_id": 1, "bundle_no": 1, "sequence": 1 });
db.procedure_progress.createIndex({ "bundle_no": 1 });
db.procedure_progress.createIndex({ "worker_name": 1, "reported_at": -1 });
```

---

## 🎯 实施步骤

### 阶段1：后端API开发（预计1天）
- [ ] 完成 Service 层工序上报方法
- [ ] 完成 Endpoint 层
- [ ] 完成 Transport 层路由
- [ ] 测试API接口

### 阶段2：小程序开发（预计2-3天）
- [ ] 设计UI页面
- [ ] 实现扫码功能
- [ ] 实现上报表单
- [ ] 区分分扎/不分扎逻辑
- [ ] 联调测试

### 阶段3：管理后台（预计1天）
- [ ] 工序进度查询页面
- [ ] 工人工资统计
- [ ] 进度报表

---

## 📌 注意事项

1. **权限控制**
   - 小程序端只允许上报操作
   - 管理后台可以查询和修改
   - 考虑工人只能看到自己的上报记录

2. **数据校验**
   - 上报数量不能超过裁剪数量
   - 不能重复上报已完成的工序
   - 工序顺序依赖（可选：需要完成前一道工序才能上报下一道）

3. **性能优化**
   - 使用批量创建减少数据库操作
   - 合理使用索引
   - 考虑缓存热点数据

4. **用户体验**
   - 扫码后自动填充信息
   - 记住上次选择的工人
   - 离线上报（缓存后同步）

---

## 📞 技术支持

如有疑问，请参考：
- [订单服务README](../app/order/README.md)
- [裁剪功能完成总结](./订单裁剪功能完成总结.md)
- [MongoDB使用指南](./MongoDB-Redis-Logger使用指南.md)
